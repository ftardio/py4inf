% LaTeX source for ``Python for Informatics: Exploring Information''
% Copyright (c)  2010-  Charles R. Severance, All Rights Reserved

\chapter{Funciones}
\label{funcchap}

\section{Llamadas a funciones}
\label{functionchap}
\index{function call}

En el contexto de la programación, una {\bf función} es una secuencia de
sentencias que realizan un cálculo y que reciben un nombre. Cuando se define una función,
es posible especificar el nombre y la secuencia de sentencias. Más adelante, se puede
``llamar'' a la función por ese nombre.
Ya hemos visto un ejemplo de una {\bf llamada a una función}:

\beforeverb
\begin{verbatim}
>>> type(32)
<type 'int'>
\end{verbatim}
\afterverb
%
El nombre de la función es {\tt type}. La expresión entre paréntesis recibe
el nombre de {\bf argumento} de la función. El argumento es
un valor o variable que se pasa a la función como parámetro de entrada.
El resultado, para la función {\tt type}, es el tipo del argumento.

\index{parentheses!argument in}

Es habitual decir que una función ``toma'' un argumento y ``retorna'' (o devuelve)
un resultado. El resultado se llama {\bf valor de retorno}.

\index{argument}
\index{return value}

\section{Funciones incorporadas}

Python proporciona un número importante de funciones incorporadas, que
pueden ser usadas sin necesidad de tener que definirlas previamente.
Los creadores de Python han escrito un conjunto de funciones
para resolver problemas comunes y las han incluido en Python para que las podamos utilizar.

Las funciones {\tt max} y {\tt min} nos darán respectivamente
el valor mayor y menor de una lista:

\beforeverb
\begin{verbatim}
>>> max('¡Hola, mundo!')
'u'
>>> min('¡Hola, mundo!')
' '
>>>
\end{verbatim}
\afterverb
%
La función {\tt max} nos dice el ``carácter más grande'' de la
cadena (que resulta ser la letra ``u''), mientras que la función
{\tt min} nos muestra el carácter más pequeño (que en ese caso es
un espacio).

Otra función incorporada muy común es {\tt len},
que nos dice cuántos elementos hay en su argumento. Si el argumento
de {\tt len} es una cadena, nos devuelve el número de caracteres
que hay en la cadena.

\beforeverb
\begin{verbatim}
>>> len('Hola, mundo')
11
>>>
\end{verbatim}
\afterverb
%
Estas funciones no se limitan a buscar en cadenas. Pueden operar con
cualquier conjunto de valores, como veremos en los siguientes capítulos.

Se deben tratar los nombres de las funciones incorporadas como si fueran palabras reservadas
(es decir, evita usar ``max'' como nombre para una variable).

\section{Funciones de conversión de tipos}
\index{conversion!type}
\index{type conversion}

% de Elkner:
% comentario acerca de si estas cosas son realmente funciones
% ¿usar max como ejemplo de una función incorporada?

% mi respuesta:
% están en la lista de ``funciones incorporadas'', de modo que estoy dispuesto
% a llamarlas funciones.

Python también proporciona funciones incorporadas que convierten valores
de un tipo a otro. La función {\tt int} toma cualquier valor y
lo convierte en un entero si puede, o se queja si no puede:

\index{int function}
\index{function!int}

\beforeverb
\begin{verbatim}
>>> int('32')
32
>>> int('Hola')
ValueError: invalid literal for int(): Hola
\end{verbatim}
\afterverb
%
{\tt int} puede convertir valores en punto flotante a enteros, pero no
los redondea; simplemente corta y descarta la parte decimal:

\beforeverb
\begin{verbatim}
>>> int(3.99999)
3
>>> int(-2.3)
-2
\end{verbatim}
\afterverb
%
{\tt float} convierte enteros y cadenas en números
de punto flotante:

\index{float function}
\index{function!float}

\beforeverb
\begin{verbatim}
>>> float(32)
32.0
>>> float('3.14159')
3.14159
\end{verbatim}
\afterverb
%
Finalmente, {\tt str} convierte su argumento en una cadena:

\index{str function}
\index{function!str}

\beforeverb
\begin{verbatim}
>>> str(32)
'32'
>>> str(3.14159)
'3.14159'
\end{verbatim}
\afterverb
%

\section{Números aleatorios}

\index{random number}
\index{number, random}
\index{deterministic}
\index{pseudorandom}

A partir de las mismas entradas, la mayoría de los ordenadores generarán
las mismas salidas cada vez, que es lo que llamamos comportamiento {\bf determinista}.
El determinismo normalmente es algo bueno, ya que esperamos realizar el mismo
cálculo para obtener el mismo resultado. Para ciertas aplicaciones, sin embargo,
querremos que el ordenador sea impredecible. Los juegos son el ejemplo
obvio, pero hay más.

Conseguir que un programa sea realmente no-determinista resulta no ser tan fácil,
pero hay modos de hacer que al menos lo parezca. Una de ellos
es usar {\bf algoritmos} que generen números {\bf pseudoaleatorios}.
Los números pseudoaleatorios no son verdaderamente aleatorios, ya que son
generados por un cálculo determinista, pero si sólo nos fijamos en los números
resulta casi imposible distinguirlos de los aleatorios de verdad.

\index{random module}
\index{module!random}

El módulo {\tt random} proporciona funciones que generan
números pseudoaleatorios (a los que simplemente llamaremos ``aleatorios''
de ahora en adelante).

\index{random function}
\index{function!random}

La función {\tt random} devuelve un número flotante aleatorio
entre 0.0 y 1.0 (incluyendo 0.0, pero no 1.0). Cada vez que se
llama a {\tt random}, se obtiene el número siguiente de una larga serie. Para ver
un ejemplo, ejecuta este bucle:

\beforeverb
\begin{verbatim}
import random

for i in range(10):
    x = random.random()
    print x
\end{verbatim}
\afterverb
%
Este programa produce la siguiente lista de 10 números aleatorios
entre 0.0 y hasta (pero no incluyendo) 1.0.

\beforeverb
\begin{verbatim}
0.301927091705
0.513787075867
0.319470430881
0.285145917252
0.839069045123
0.322027080731
0.550722110248
0.366591677812
0.396981483964
0.838116437404
\end{verbatim}
\afterverb
%
\begin{ex}
Ejecuta el programa en tu sistema y observa qué números obtienes.
\end{ex}

La función {\tt random} es solamente na de las muchas
que trabajan con números aleatorios.
La función {\tt randint} toma los parámetros {\tt inferior} y
{\\ superior}, y devuelve un entero entre {\tt inferior} y 
{\tt superior} (incluyendo ambos extremos).

\index{randint function}
\index{function!randint}

\beforeverb
\begin{verbatim}
>>> random.randint(5, 10)
5
>>> random.randint(5, 10)
9
\end{verbatim}
\afterverb
%
Para elegir un elemento de una secuencia aleatoriamente, se puede usar
{\tt choice}:

\index{choice function}
\index{function!choice}

\beforeverb
\begin{verbatim}
>>> t = [1, 2, 3]
>>> random.choice(t)
2
>>> random.choice(t)
3
\end{verbatim}
\afterverb
%
El módulo {\tt random} también proporciona funciones para generar
valores aleatorios de distribuciones continuas, incluyendo
Gausiana, exponencial, gamma, y unas cuantas más.

\section{Funciones matemáticas}
\index{math function}
\index{function, math}
\index{module}
\index{module object}

Python tienen un módulo {\tt matemático (math)}, que proporciona la mayoría
de las funciones matemáticas habituales.
Antes de que se pueda utilizar el módulo, hay que importarlo:

\beforeverb
\begin{verbatim}
>>> import math
\end{verbatim}
\afterverb
%
Esta sentencia crea un {\bf objeto módulo} llamado math. Si
se imprime el objeto módulo, se obtiene alguna información sobre él:

\beforeverb
\begin{verbatim}
>>> print math
<module 'math' from '/usr/lib/python2.5/lib-dynload/math.so'>
\end{verbatim}
\afterverb
%
El objeto módulo contiene la función y variables definidas en el módulo.
Para acceder a una de esas funciones, es necesario especificar el nombre
del módulo y el nombre de la función, separados por un punto (también
conocido como período). Este formato recibe el nombre de {\bf notación punto}.

\index{dot notation}

\beforeverb
\begin{verbatim}
>>> relacion = int_senal / int_ruido
>>> decibelios = 10 * math.log10(relacion)

>>> radianes = 0.7
>>> altura = math.sin(radianes)
\end{verbatim}
\afterverb
%
El primer ejemplo calcula el logaritmo base 10 de la
relación señal-ruido. El módulo math también proporciona una
función llamada {\tt log} que calcula logaritmos en base {\tt e}.

\index{log function}
\index{function!log}
\index{sine function}
\index{radian}
\index{trigonometric function}
\index{function, trigonometric}

El segundo ejemplo calcula el seno de la variable {\tt radianes}. El nombre de la
variable es una pista de que {\tt sin} y las otras funciones
trigonométricas ({\tt cos}, {\tt tan}, etc.) toman argumentos en radianes.
Para convertir de grados a radianes, hay que dividir por 360 y multiplicar por
$2\pi$:

\beforeverb
\begin{verbatim}
>>> grados = 45
>>> radianes = grados / 360.0 * 2 * math.pi
>>> math.sin(radianes)
0.707106781187
\end{verbatim}
\afterverb
%
La expresión {\tt math.pi} toma la variable {\tt pi} del módulo math.
El valor de esa variable es una aproximación de
$\pi$, con una precisión de unos 15 dígitos.

\index{pi}

Si sabes de
trigonometría, puedes comprobar el resultado anterior, comparándolo con
la raíz cuadrada de dos dividida por dos:

\index{sqrt function}
\index{function!sqrt}

\beforeverb
\begin{verbatim}
>>> math.sqrt(2) / 2.0
0.707106781187
\end{verbatim}
\afterverb
%


\section{Añadiendo funciones nuevas}

Hasta ahora, sólo hemos estado usando las funciones que vienen incorporadas en Python,
pero es posible también añadir funciones nuevas.
Una {\bf definición de función} especifica el nombre de una función nueva y
la secuencia de sentencias que ejecuta cuando la función es llamada.
Una vez definida una función, se puede reutilizar una y otra vez
a lo largo de todo el programa.

\index{function}
\index{function definition}
\index{definition!function}

He aquí un ejemplo:

\beforeverb
\begin{verbatim}
def print_lyrics():
    print "Soy un leñador, y me siento bien."
    print 'Duermo toda la noche y trabajo todo el día.'
\end{verbatim}
\afterverb
%
{\tt def} es una palabra clave que indica que se trata de una definición
de función. El nombre de la función es \verb"print_lyrics". Las
reglas para los nombres de las funciones son los mismos que para las variables:
se pueden usar letras, números y algunos signos de puntuación, pero el primer carácter
no puede ser un número. No se pueden usar una palabra clave como nombre de una función,
y se debería evitar tener una variable y una función con el mismo
nombre.

\index{def keyword}
\index{keyword!def}
\index{argument}

Los paréntesis vacíos después del nombre indican que esta función
no toma ningún argumento. Más tarde construiremos funciones que
toman argumentos de entrada.

\index{parentheses!empty}
\index{header}
\index{body}
\index{indentation}
\index{colon}

La primera línea de la definición de la función es llamada la {\bf cabecera};
el resto se llama el {\bf cuerpo}. La cabecera debe terminar con dos-puntos (:),
y el cuerpo debe ir sangrado. Por convención, el sangrado es
siempre de cuatro espacios. El cuerpo puede contener
cualquier número de sentencias.

Las cadenas en la sentencia print están encerradas entre
comillas. Da igual utilizar comillas simples que dobles;
la mayoría de la gente prefiere comillas simples, excepto en aquellos casos en los que
una comilla simple (que también se usa como apostrofe) aparece en medio de la cadena.

\index{ellipses}

Si escribes una definición de función en modo interactivo, el intérprete
mostrará puntos suspensivos (\emph{...}) para hacerte saber que la definición
no está completa:

\beforeverb
\begin{verbatim}
>>> def print_lyrics():
...     print "Soy un leñador, y me siento bien."
...     print 'Duermo toda la noche y trabajo todo el día.'
...
\end{verbatim}
\afterverb
%
Para finalizar la función, debes introducir una línea vacía (esto no
es necesario en un script).

Al definir una función se crea una variable con el mismo nombre.

\beforeverb
\begin{verbatim}
>>> print print_lyrics
<function print_lyrics at 0xb7e99e9c>
>>> print type(print_lyrics)
<type 'function'>
\end{verbatim}
\afterverb
%
El valor de \verb"print_lyrics" es {\bf function object (objeto función)}, que
tiene como tipo \verb"'function'".

\index{function object}
\index{object!function}

La sintaxis para llamar a la nueva función es la misma que
la de las funciones incorporadas:

\beforeverb
\begin{verbatim}
>>> print_lyrics()
Soy un leñador, y me siento bien.
Duermo toda la noche y trabajo todo el día.
\end{verbatim}
\afterverb
%
Una vez que se ha definido una función, puede usarse dentro de otra.
Por ejemplo, para repetir el refrán anterior, podríamos escribir
una función llamada \verb"repeat_lyrics":

\beforeverb
\begin{verbatim}
def repeat_lyrics():
    print_lyrics()
    print_lyrics()
\end{verbatim}
\afterverb
%
Y después llamar a \verb"repeat_lyrics":

\beforeverb
\begin{verbatim}
>>> repeat_lyrics()
Soy un leñador, y me siento bien.
Duermo toda la noche y trabajo todo el día.
Soy un leñador, y me siento bien.
Duermo toda la noche y trabajo todo el día.
\end{verbatim}
\afterverb
%
Pero la canción en realidad no es así.

\section{Definición y usos}
\index{function definition}

Reuniendo los fragmentos de código de las secciones anteriores, el
programa completo sería algo esto:

\beforeverb
\begin{verbatim}
def print_lyrics():
    print "Soy un leñador, y me siento bien."
    print 'Duermo toda la noche y trabajo todo el día.'

def repeat_lyrics():
    print_lyrics()
    print_lyrics()

repeat_lyrics()
\end{verbatim}
\afterverb
%
Este programa contiene dos definiciones de funciones: \verb"print_lyrics" y
\verb"repeat_lyrics". Las definiciones de funciones son ejecutadas exactamente
igual que cualquier otra sentencia, pero lo que se consigue es crear objetos del tipo función. Las
sentencias dentro de esa función no se ejecutarán hasta que no se llame a la función,
y la definición de la función no genera ninguna salida.

\index{use before def}

Como ya te imaginarás, es necesario crear una función antes de que se
pueda ejecutar. En otras palabras, la definición de la función debe ser
ejecutada antes de que la función se llame por primera vez.

\begin{ex}
Mueve la última línea de este programa
hacia arriba, de modo que la llamada a la función aparezca antes de las
definiciones. Ejecuta
el programa y observa qué mensaje
de error obtienes.
\end{ex}

\begin{ex}
Mueve la llamada de la función de nuevo hacia el final,
y coloca la definición de \verb"print_lyrics" después de la definición
de \verb"repeat_lyrics". ¿Qué ocurre cuando haces funcionar este programa?
\end{ex}


\section{Flujo de ejecución}
\index{flow of execution}

Para asegurarnos de que una función está definida antes de usarla por primera vez,
es necesario saber el orden en que las sentencias son ejecutadas, que es lo
que llamamos el {\bf flujo de ejecución}.

La ejecución siempre comienza en la primera sentencia del programa.
Las sentencias son ejecutadas una por una, en orden de arriba hacia abajo.

Las \emph{definiciones} de funciones no alteran el flujo de la ejecución del
programa, pero recuerda que las sentencias dentro de una función no son
ejecutadas hasta que se llama a esa función.

Una llamada a una función es como un desvío en el flujo de la ejecución. En vez
de pasar a la siguiente sentencia, el flujo salta al cuerpo de
la función, ejecuta todas las sentencias que hay allí, y después vuelve
al punto donde lo dejó.

Esto parece bastante simple, hasta que uno recuerda que una función puede
llamar a otra. Cuando está en medio de una función, el programa puede
tener que ejecutar las sentencias de otra función. Pero cuando
está ejecutando esa nueva función, ¡tal vez el programa tenga que ejecutar
todavía otra función más!

Afortunadamente, Python es hábil llevando el seguimiento de dónde se encuentra en cada momento, de modo
que cada vez que completa la ejecución de una función, el programa vuelve al punto donde lo dejó
en la función que había llamado a esa. Cuando esto le lleva hasta el final del programa,
simplemente termina.

¿Cuál es la moraleja de esta sórdida historia? Cuando leas un programa, no
siempre querrás hacerlo de arriba a abajo. A veces tiene más
sentido seguir el flujo de la ejecución.

\section{Parámetros y argumentos}
\label{parameters}
\index{parameter}
\index{function parameter}
\index{argument}
\index{function argument}

Algunas de las funciones incorporadas que hemos visto necesitan argumentos. Por
ejemplo, cuando se llama a {\tt math.sin}, se le pasa un número
como argumento. Algunas funciones necesitan más de un argumento:
{\tt math.pow} toma dos, la base y el exponente.

Dentro de las funciones, los argumentos son asignados a
variables llamadas {\bf parámetros}. A continuación mostramos un ejemplo
de una función definida por el usuario que toma un argumento:

\index{parentheses!parameters in}

\beforeverb
\begin{verbatim}
def print_twice(bruce):
    print bruce
    print bruce
\end{verbatim}
\afterverb
%
Esta función asigna el argumento a un parámetro
llamado {\tt bruce}. Cuando la función es llamada, imprime el valor del
parámetro (sea éste lo que sea) dos veces.

Esta función funciona con cualquier valor que pueda ser imprimido en pantalla.

\beforeverb
\begin{verbatim}
>>> print_twice('Spam')
Spam
Spam
>>> print_twice(17)
17
17
>>> print_twice(math.pi)
3.14159265359
3.14159265359
\end{verbatim}
\afterverb
%
Las mismas reglas de composición que se aplican a las funciones incorporadas, también
se aplican a las funciones definidas por el usuario, de modo que podemos usar cualquier tipo
de expresión como argumento para \verb"print_twice":

\index{composition}

\beforeverb
\begin{verbatim}
>>> print_twice('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam
>>> print_twice(math.cos(math.pi))
-1.0
-1.0
\end{verbatim}
\afterverb
%
El argumento es evaluado antes de que función sea llamada, así
que en los ejemplos, la expresión \verb"'Spam '*4" y
{\tt math.cos(math.pi)} son evaluadas una sola vez.

\index{argument}

También se puede usar una variable como argumento:

\beforeverb
\begin{verbatim}
>>> michael = 'Eric, el medio-abeja.'
>>> print_twice(michael)
Eric, el medio-abeja.
Eric, el medio-abeja.
\end{verbatim}
\afterverb
%
El nombre de la variable que pasamos como argumento, ({\tt michael}) no
tiene nada que ver con el nombre del parámetro ({\tt bruce}). No
importa cómo se haya llamado al valor en casa (en la llamada);
dentro de \verb"print_twice", siempre se llamará {\tt bruce}.

\section{Funciones fructíferas y funciones vacuas}

\index{fruitful function}
\index{void function}
\index{function, fruitful}
\index{function, void} 

Algunas de las funciones que estamos usando, como las matemáticas, producen
resultados; a falta de un nombre mejor, las llamaremos {\bf funciones fructíferas (fruitful functions)}.
Otras funciones, como \verb"print_twice", realizan una
acción, pero no devuelven un valor. A esas las llamaremos {\bf funciones
vacuas (void functions)}.

Cuando llamas a una función fructífera, casi siempre
querrás hacer luego algo con el resultado; por ejemplo, puede
que quieras asignarlo a una variable o usarlo como parte de una expresión:

\beforeverb
\begin{verbatim}
x = math.cos(radians)
golden = (math.sqrt(5) + 1) / 2
\end{verbatim}
\afterverb
%
Cuando llamas a una función en modo interactivo, Python muestra
el resultado:

\beforeverb
\begin{verbatim}
>>> math.sqrt(5)
2.2360679774997898
\end{verbatim}
\afterverb
%
Pero en un script, si llamas a una función fructífera y no
almacenas el resultado de la misma en una variable,
¡el valor de retorno se desvanece en la niebla!

\beforeverb
\begin{verbatim}
math.sqrt(5)
\end{verbatim}
\afterverb
%
Este script calcula la raíz cuadrada de 5, pero dado que no almacena
el resultado en una variable ni lo muestra, no resulta en realidad muy útil.

\index{interactive mode}
\index{script mode}

Las funciones vacuas pueden mostrar algo en la pantalla o tener cualquier
otro efecto, pero no devuelven un valor. Si intentas asignar
el resultado a una variable, obtendrás un valor especial llamado
{\tt None (nada)}.

\index{None special value}
\index{special value!None}

\beforeverb
\begin{verbatim}
>>> resultado = print_twice('Bing')
Bing
Bing
>>> print resultado
None
\end{verbatim}
\afterverb
%
El valor {\tt None} no es el mismo que la cadena \verb"'None'".
Es un valor especial que tiene su propio tipo:

\beforeverb
\begin{verbatim}
>>> print type(None)
<type 'NoneType'>
\end{verbatim}
\afterverb
%
Para devolver un resultado desde una función, usamos la sentencia {\\return}
dentro de ella. Por ejemplo, podemos crear una función
muy simple llamada {\tt sumados},
que suma dos números y devuelve el resultado.

\beforeverb
\begin{verbatim}
def sumados(a, b):
    suma = a + b
    return suma

x = sumados(3, 5)
print x
\end{verbatim}
\afterverb
%
Cuando se ejecuta este script, la sentencia {\tt print} mostrará ``8'',
ya que la función {\tt sumados} ha sido llamada con 3 y 5 como argumentos.
Dentro de la función, los parámetros {\tt a} y {\tt b} equivaldrán a 3 y a 5
respectivamente. La función calculó la suma de ambos número y la guardó
en una variable local a la función llamada {\tt suma}.
Después usó la sentencia {\tt return}
para enviar el valor calculado de vuelta al código de llamada
como resultado de la función, que fue asignado
a la variable {\tt x} y mostrado en pantalla.

\section{¿Por qué funciones?}
\index{function, reasons for}

Puede no estar muy claro por qué merece la pena molestarse en dividir
un programa en funciones. Existen varias razones:

\begin{itemize}

\item El crear una función nueva te da oportunidad de dar nombre a un grupo
de sentencias, lo cual hace tu programa más fácil de leer, entender,
y depurar.

\item Las funciones pueden hacer un programa más pequeño, al eliminar código
repetido. Además, si quieres hacer cualquier cambio más tarde, sólo tendrás
que hacerlo en un único lugar.

\item Dividir un programa largo en funciones te permite depurar las
partes de una en una y luego ensamblarlas juntas en una sola pieza.

\item Las funciones bien designadas a menudo resultan útiles para muchos programas.
Una vez que has escrito y depurado una, puedes reutilizarla.

\end{itemize}

A lo largo del resto del libro, a menudo usaremos una definición de función para
explicar un concepto. Parte de la habilidad de crear y usar funciones consiste en llegar a
tener una función que capture correctamente una idea, como ``encontrar el valor
más pequeño en una lista de valores''. Más adelante te mostraremos el código para
encontrar el valor más pequeño de una lista de valores y te lo presentaremos como
una función llamada {\tt min}, que toma una lista de valores como argumento y
devuelve el valor menor de esa lista.


\section{Depurando}
\label{editor}
\index{debugging}

Si estás usando un editor de texto para escribir tus propios scripts, puede
que tengas problemas con los espacios y tabulaciones. El mejor modo de evitar
esos problemas es usar espacios exclusivamente (no tabulaciones). La mayoría
de los editores de texto que reconocen Python lo hacen así por efecto, aunque
hay algunos que no.

\index{whitespace}

Las tabulaciones y los espacios normalmente son invisibles, lo cual hace
que sea difícil depurar los errores que pueden producir, así que mejor
busca un editor que gestione el sangrado por ti.

Tampoco te olvides de guardar tu programa antes de hacerlo funcionar. Algunos
entornos de desarrollo lo hacen automáticamente, pero otros no.
En ese caso, el programa que estás viendo en el editor de texto
puede no ser el mismo que estás ejecutando en realidad.

¡La depuración puede llevar mucho tiempo si estás haciendo funcionar el
mismo programa erróneo una y otra vez!

Asegúrate que el código que estás examinando es el mismo que estás ejecutando.
Si no estás seguro, pon algo como \verb"print 'hola'" al principio
del programa y hazlo funcionar de nuevo. Si no ves \verb"print 'hola" en la
pantalla, ¡es que no estás ejecutando el programa correcto!


\section{Glosario}

\begin{description}

\item[algoritmo:]  Un proceso general para resolver una categoría de problemas.
\index{algorithm}

\item[argumento:]  Un valor proporcionado a una función cuando ésta es llamada.
Ese valor se asigna al parámetro correspondiente en la función.
\index{argument}

\item[cabecera:] La primera línea de una definición de función.
\index{header}

\item[cuerpo:] La secuencia de sentencias dentro de la definición de una función.
\index{body}

\item[composición:] Uso de una expresión o sentencia como parte de otra más larga,
\index{composition}

\item[definición de función:] Una sentencia que crea una función nueva,
especificando su nombre, parámetros, y las sentencias que ejecuta.
\index{function definition}

\item[determinístico:] Perteneciente a un programa que hace lo mismo
cada vez que se ejecuta, a partir de las mismas entradas.
\index{deterministic}

\item[función:] Una secuencia de sentencias con un nombre que realizan alguna
operación útil. Las funciones pueden tomar argumentos o no, y pueden
producir un resultado o no.
\index{function}

\item[función fructífera (fruitful function):] Una función que devuelve un valor.
\index{fruitful function}

\item[función vacua (void function):] Una función que no devuelve ningún valor.
\index{void function}

\item[flujo de ejecución:] El orden en el cual las sentencias son ejecutadas durante
el funcionamiento de un programa.
\index{flow of execution}

\item[llamada a función:] Una sentencia que ejecuta una función. Consiste en
el nombre de la función seguido por una lista de argumentos.
\index{function call}

\item[notación punto:] La sintaxis de llamada a una función en
otro módulo, especificando el nombre del módulo seguido por un punto y el
nombre de la función.
\index{dot notation}

\item[objeto función:]  Un valor creado por una definición de función.
El nombre de la función es una variable que se refiere al objeto
función.
\index{function definition}

\item[objeto módulo:] Un valor creado por una sentencia {\tt import},
que proporciona acceso a los datos y código definidos en un módulo.
\index{module}

\item[parámetro:] Un nombre usado dentro de una función para referirse al valor
pasado como argumento.
\index{parameter}

\item[pseudoaleatorio:] Perteneciente a una secuencia de números que parecen
ser aleatorios, pero son generados por un programa determinista.
\index{pseudorandom}

\item[sentencia import:] Una sentencia que lee un archivo módulo y crea
un objeto módulo.
\index{import statement}
\index{statement!import}

\item[valor de retorno:] El resultado de una función. Si una llamada a una función
es usada como una expresión, el valor de retorno es el valor de
la expresión.
\index{return value}

\end{description}


\section{Ejercicios}

\begin{ex}
¿Cuál es la utilidad de la palabra clave "def" en Python?

a) Es una jerga que significa "este código es realmente estupendo"\\
b) Indica el comienzo de una función\\
c) Indica que la siguiente sección de código sangrada debe ser almacenada para usarla más tarde\\
d) b y c son correctas ambas\\
e) Ninguna de las anteriores
\end{ex}

\begin{ex}
¿Qué mostrará en pantalla en siguiente programa Python?

\beforeverb
\begin{verbatim}
def fred():
   print "Zap"

def jane():
   print "ABC"

jane()
fred()
jane()
\end{verbatim}
\afterverb
%
a) Zap ABC jane fred jane\\
b) Zap ABC Zap\\
c) ABC Zap jane\\
d) ABC Zap ABC\\
e) Zap Zap Zap
\end{ex}

\begin{ex}
Reescribe el programa de cálculo del salario, con tarifa-y-media para las horas extras,
y crea una función llamada {\tt calculosalario} que tome
dos parámetros ({\tt horas} y {\tt tarifa}).

\begin{verbatim}
Introduce Horas: 45
Introduce Tarifa: 10
Salario: 475.0
\end{verbatim}
\end{ex}

\begin{ex}
Reescribe el programa de calificaciones del capítulo anterior
usando una función llamada {\tt calculacalificacion}, que tome
una puntuación como parámetro y devuelva una calificación como cadena.

\begin{verbatim}
Puntuación Calificación
> 0.9      Sobresaliente
> 0.8      Notable
> 0.7      Bien
> 0.6      Suficiente
<= 0.6     Insuficiente

Ejecución del programa:

Introduce puntuación: 0.95
Sobresaliente

Introduce puntuación: perfecto
Puntuación incorrecta

Introduce puntuación: 10.0
Puntuación incorrecta

Introduce puntuación: 0.75
Bien

Introduce puntuación: 0.5
Insuficiente
\end{verbatim}

Ejecuta el programa repetidamente para probar varios valores diferentes
como entrada.
\end{ex}


