% LaTeX source for ``Python for Informatics: Exploring Information''
% Copyright (c)  2010-  Charles R. Severance, All Rights Reserved

\chapter{Funciones}
\label{funcchap}

\section{Llamadas a funciones}
\label{functionchap}
\index{función, llamada a}

En el contexto de la programación, una {\bf función} es una secuencia de
sentencias que realizan una operación y que reciben un nombre. Cuando se define una función,
se especifica el nombre y la secuencia de sentencias. Más adelante, se puede
``llamar'' a la función por ese nombre.
Ya hemos visto un ejemplo de una {\bf llamada a una función}:

\beforeverb
\begin{verbatim}
>>> type(32)
<type 'int'>
\end{verbatim}
\afterverb
%
El nombre de la función es {\tt type}. La expresión entre paréntesis recibe
el nombre de {\bf argumento} de la función. El argumento es
un valor o variable que se pasa a la función como parámetro de entrada.
El resultado de la función {\tt type} es el tipo del argumento.

\index{paréntesis!argumento in}

Es habitual decir que una función ``toma'' (o recibe) un argumento y ``retorna'' (o devuelve)
un resultado. El resultado se llama {\bf valor de retorno}.

\index{argumento}
\index{valor de retorno}

\section{Funciones internas}

Python proporciona un número importante de funciones internas, que
pueden ser usadas sin necesidad de tener que definirlas previamente.
Los creadores de Python han escrito un conjunto de funciones
para resolver problemas comunes y las han incluido en Python para que las podamos utilizar.

Las funciones {\tt max} y {\tt min} nos darán respectivamente
el valor mayor y menor de una lista:

\beforeverb
\begin{verbatim}
>>> max('¡Hola, mundo!')
'u'
>>> min('¡Hola, mundo!')
' '
>>>
\end{verbatim}
\afterverb
%
La función {\tt max} nos dice cuál es el ``carácter más grande'' de la
cadena (que resulta ser la letra ``u''), mientras que la función
{\tt min} nos muestra el carácter más pequeño (que en ese caso es
un espacio).

Otra función interna muy común es {\tt len},
que nos dice cuántos elementos hay en su argumento. Si el argumento
de {\tt len} es una cadena, nos devuelve el número de caracteres
que hay en la cadena.

\beforeverb
\begin{verbatim}
>>> len('Hola, mundo')
11
>>>
\end{verbatim}
\afterverb
%
Estas funciones no se limitan a buscar en cadenas. Pueden operar con
cualquier conjunto de valores, como veremos en los siguientes capítulos.

Se deben tratar los nombres de las funciones internas como si fueran palabras reservadas
(es decir, evita usar ``max'' como nombre para una variable).

\section{Funciones de conversión de tipos}
\index{conversión!tipo}
\index{tipo, conversión de}

% de Elkner:
% comentario acerca de si estas cosas son realmente funciones
% ¿usar max como ejemplo de una función incorporada?

% mi respuesta:
% están en la lista de ``funciones incorporadas'', de modo que estoy dispuesto
% a llamarlas funciones.

Python también proporciona funciones internas que convierten valores
de un tipo a otro. La función {\tt int} toma cualquier valor y
lo convierte en un entero, si puede, o se queja si no puede:

\index{int, función}
\index{función!int}

\beforeverb
\begin{verbatim}
>>> int('32')
32
>>> int('Hola')
ValueError: invalid literal for int(): Hola
\end{verbatim}
\afterverb
%
{\tt int} puede convertir valores en punto flotante a enteros, pero no
los redondea; simplemente corta y descarta la parte decimal:

\beforeverb
\begin{verbatim}
>>> int(3.99999)
3
>>> int(-2.3)
-2
\end{verbatim}
\afterverb
%
{\tt float} convierte enteros y cadenas en números
de punto flotante:

\index{float, función}
\index{función!float}

\beforeverb
\begin{verbatim}
>>> float(32)
32.0
>>> float('3.14159')
3.14159
\end{verbatim}
\afterverb
%
Finalmente, {\tt str} convierte su argumento en una cadena:

\index{str, función}
\index{función!str}

\beforeverb
\begin{verbatim}
>>> str(32)
'32'
>>> str(3.14159)
'3.14159'
\end{verbatim}
\afterverb
%

\section{Números aleatorios}

\index{aleatorio, número}
\index{número, aleatorio}
\index{determinístico}
\index{pseudoaleatorio}

A partir de las mismas entradas, la mayoría de los programas generarán
las mismas salidas cada vez, que es lo que llamamos comportamiento {\bf determinista}.
El determinismo normalmente es algo bueno, ya que esperamos que la misma
operación nos proporcione siempre el mismo resultado. Para ciertas aplicaciones, sin embargo,
querremos que el equipo sea impredecible. Los juegos son el ejemplo
obvio, pero hay más.

Conseguir que un programa sea realmente no-determinista no resulta tan fácil,
pero hay modos de hacer que al menos lo parezca. Una de ellos
es usar {\bf algoritmos} que generen números {\bf pseudoaleatorios}.
Los números pseudoaleatorios no son verdaderamente aleatorios, ya que son
generados por una operación determinista, pero si sólo nos fijamos en los números
resulta casi imposible distinguirlos de los aleatorios de verdad.

\index{random, módulo}
\index{módulo!random}

El módulo {\tt random} proporciona funciones que generan
números pseudoaleatorios (a los que simplemente llamaremos ``aleatorios''
de ahora en adelante).

\index{random, función}
\index{función!random}

La función {\tt random} devuelve un número flotante aleatorio
entre 0.0 y 1.0 (incluyendo 0.0, pero no 1.0). Cada vez que se
llama a {\tt random}, se obtiene el número siguiente de una larga serie. Para ver
un ejemplo, ejecuta este bucle:

\beforeverb
\begin{verbatim}
import random

for i in range(10):
    x = random.random()
    print x
\end{verbatim}
\afterverb
%
Este programa produce la siguiente lista de 10 números aleatorios
entre 0.0 y hasta (pero no incluyendo) 1.0.

\beforeverb
\begin{verbatim}
0.301927091705
0.513787075867
0.319470430881
0.285145917252
0.839069045123
0.322027080731
0.550722110248
0.366591677812
0.396981483964
0.838116437404
\end{verbatim}
\afterverb
%
\begin{ex}
Ejecuta el programa en tu sistema y observa qué números obtienes.
\end{ex}

La función {\tt random} es solamente una de las muchas
que trabajan con números aleatorios.
La función {\tt randint} toma los parámetros {\tt inferior} y
{\tt superior}, y devuelve un entero entre {\tt inferior} y 
{\tt superior} (incluyendo ambos extremos).

\index{randint, función}
\index{función!randint}

\beforeverb
\begin{verbatim}
>>> random.randint(5, 10)
5
>>> random.randint(5, 10)
9
\end{verbatim}
\afterverb
%
Para elegir un elemento de una secuencia aleatoriamente, se puede usar
{\tt choice}:

\index{choice, función}
\index{función!choice}

\beforeverb
\begin{verbatim}
>>> t = [1, 2, 3]
>>> random.choice(t)
2
>>> random.choice(t)
3
\end{verbatim}
\afterverb
%
El módulo {\tt random} también proporciona funciones para generar
valores aleatorios de distribuciones continuas, incluyendo
Gausiana, exponencial, gamma, y unas cuantas más.

\section{Funciones matemáticas}
\index{math, función}
\index{función!math}
\index{módulo}
\index{módulo, objeto}

Python tiene un módulo  matemático {\tt (math)}, que proporciona la mayoría
de las funciones matemáticas habituales.
Antes de que podamos utilizar el módulo, deberemos importarlo:

\beforeverb
\begin{verbatim}
>>> import math
\end{verbatim}
\afterverb
%
Esta sentencia crea un {\bf objeto módulo} llamado math. Si
se imprime el objeto módulo, se obtiene cierta información sobre él:

\beforeverb
\begin{verbatim}
>>> print math
<module 'math' from '/usr/lib/python2.5/lib-dynload/math.so'>
\end{verbatim}
\afterverb
%
El objeto módulo contiene la función y variables definidas en el módulo.
Para acceder a una de esas funciones, es necesario especificar el nombre
del módulo y el nombre de la función, separados por un punto (también
conocido como período). Este formato recibe el nombre de {\bf notación punto}.

\index{notación punto}

\beforeverb
\begin{verbatim}
>>> relacion = int_senal / int_ruido
>>> decibelios = 10 * math.log10(relacion)

>>> radianes = 0.7
>>> altura = math.sin(radianes)
\end{verbatim}
\afterverb
%
El primer ejemplo calcula el logaritmo base 10 de la
relación señal-ruido. El módulo math también proporciona una
función llamada {\tt log} que calcula logaritmos en base {\tt e}.

\index{log, función}
\index{función!log}
\index{sine, función}
\index{radián}
\index{trigonométrica, función}
\index{función, trigonométrica}

El segundo ejemplo calcula el seno de la variable {\tt radianes}. El nombre de la
variable es una pista de que {\tt sin} y las otras funciones
trigonométricas ({\tt cos}, {\tt tan}, etc.) toman argumentos en radianes.
Para convertir de grados a radianes, hay que dividir por 360 y multiplicar por
$2\pi$:

\beforeverb
\begin{verbatim}
>>> grados = 45
>>> radianes = grados / 360.0 * 2 * math.pi
>>> math.sin(radianes)
0.707106781187
\end{verbatim}
\afterverb
%
La expresión {\tt math.pi} toma la variable {\tt pi} del módulo math.
El valor de esa variable es una aproximación de
$\pi$, con una precisión de unos 15 dígitos.

\index{pi}

Si sabes de
trigonometría, puedes comprobar el resultado anterior, comparándolo con
la raíz cuadrada de dos dividida por dos:

\index{sqrt, función}
\index{función!sqrt}

\beforeverb
\begin{verbatim}
>>> math.sqrt(2) / 2.0
0.707106781187
\end{verbatim}
\afterverb
%


\section{Añadiendo funciones nuevas}

Hasta ahora, sólo hemos estado usando las funciones que vienen incorporadas en Python,
pero es posible añadir también funciones nuevas.
Una {\bf definición de función} especifica el nombre de una función nueva y
la secuencia de sentencias que se ejecutan cuando esa función es llamada.
Una vez definida una función, se puede reutilizar una y otra vez
a lo largo de todo el programa.

\index{función}
\index{función, definición}
\index{definición!función}

He aquí un ejemplo:

\beforeverb
\begin{verbatim}
def muestra_estribillo():
    print 'Soy un leñador, qué alegría.'
    print 'Duermo toda la noche y trabajo todo el día.'
\end{verbatim}
\afterverb
%
{\tt def} es una palabra clave que indica que se trata de una definición
de función. El nombre de la función es \verb"muestra_estribillo". Las
reglas para los nombres de las funciones son los mismos que para las variables:
se pueden usar letras, números y algunos signos de puntuación, pero el primer carácter
no puede ser un número. No se puede usar una palabra clave como nombre de una función,
y se debería evitar también tener una variable y una función con el mismo
nombre.

\index{def, palabra clave}
\index{palabra clave!def}
\index{argumento}

Los paréntesis vacíos después del nombre indican que esta función
no toma ningún argumento. Más tarde construiremos funciones que
reciban argumentos de entrada.

\index{paréntesis!vacíos}
\index{cabecera}
\index{cuerpo}
\index{indentado}
\index{dos-puntos}

La primera línea de la definición de la función es llamada la {\bf cabecera};
el resto se llama el {\bf cuerpo}. La cabecera debe terminar con dos-puntos (:),
y el cuerpo debe ir indentado. Por convención, el indentado es
siempre de cuatro espacios. El cuerpo puede contener
cualquier número de sentencias.

Las cadenas en la sentencia print están encerradas entre
comillas. Da igual utilizar comillas simples que dobles;
la mayoría de la gente prefiere comillas simples, excepto en aquellos casos en los que
una comilla simple (que también se usa como apostrofe) aparece en medio de la cadena.

\index{puntos suspensivos}

Si escribes una definición de función en modo interactivo, el intérprete
mostrará puntos suspensivos (\emph{...}) para informarte de que la definición
no está completa:

\beforeverb
\begin{verbatim}
>>> def muestra_estribillo():
...     print 'Soy un leñador, qué alegría.'
...     print 'Duermo toda la noche y trabajo todo el día.'
...
\end{verbatim}
\afterverb
%
Para finalizar la función, debes introducir una línea vacía (esto no
es necesario en un script).

Al definir una función se crea una variable con el mismo nombre.

\beforeverb
\begin{verbatim}
>>> print muestra_estribillo
<function muestra_estribillo at 0xb7e99e9c>
>>> print type(muestra_estribillo)
<type 'function'>
\end{verbatim}
\afterverb
%
El valor de \verb"muestra_estribillo" es {\bf function object} (objeto función), que
tiene como tipo \verb"'function'".

\index{función, objeto}
\index{objeto!función}

La sintaxis para llamar a nuestra nueva función es la misma que
usamos para las funciones internas:

\beforeverb
\begin{verbatim}
>>> muestra_estribillo()
Soy un leñador, qué alegría.
Duermo toda la noche y trabajo todo el día.
\end{verbatim}
\afterverb
%
Una vez que se ha definido una función, puede usarse dentro de otra.
Por ejemplo, para repetir el estribillo anterior, podríamos escribir
una función llamada \verb"repite_estribillo":

\beforeverb
\begin{verbatim}
def repite_estribillo():
    muestra_estribillo()
    muestra_estribillo()
\end{verbatim}
\afterverb
%
Y después llamar a \verb"repite_estribillo":

\beforeverb
\begin{verbatim}
>>> repite_estribillo()
Soy un leñador, qué alegría.
Duermo toda la noche y trabajo todo el día.
Soy un leñador, qué alegría.
Duermo toda la noche y trabajo todo el día.
\end{verbatim}
\afterverb
%
Pero en realidad la canción no es así.

\section{Definición y usos}
\index{función, definición}

Reuniendo los fragmentos de código de las secciones anteriores, el
programa completo sería algo como esto:

\beforeverb
\begin{verbatim}
def muestra_estribillo():
    print 'Soy un leñador, que alegría.'
    print 'Duermo toda la noche y trabajo todo el día.'

def repite_estribillo():
    muestra_estribillo()
    muestra_estribillo()

repite_estribillo()
\end{verbatim}
\afterverb
%
Este programa contiene dos definiciones de funciones: \verb"muestra_estribillo" y
\verb"repite_estribillo". Las definiciones de funciones son ejecutadas exactamente
igual que cualquier otra sentencia, pero su resultado consiste en crear objetos del tipo función. Las
sentencias dentro de cada función son ejecutadas solamente cuando se llama a esa función,
y la definición de una función no genera ninguna salida.

\index{use before def}

Como ya te imaginarás, es necesario crear una función antes de que se
pueda ejecutar. En otras palabras, la definición de la función debe ser
ejecutada antes de que la función se llame por primera vez.

\begin{ex}
Desplaza la última línea de este programa
hacia arriba, de modo que la llamada a la función aparezca antes que las
definiciones. Ejecuta
el programa y observa qué mensaje
de error obtienes.
\end{ex}

\begin{ex}
Desplaza la llamada de la función de nuevo hacia el final,
y coloca la definición de \verb"muestra_estribillo" después de la definición
de \verb"repite_estribillo". ¿Qué ocurre cuando haces funcionar ese programa?
\end{ex}


\section{Flujo de ejecución}
\index{flujo de ejecución}

Para asegurarnos de que una función está definida antes de usarla por primera vez,
es necesario saber el orden en que las sentencias son ejecutadas, que es lo
que llamamos el {\bf flujo de ejecución}.

La ejecución siempre comienza en la primera sentencia del programa.
Las sentencias son ejecutadas una por una, en orden de arriba hacia abajo.

Las \emph{definiciones} de funciones no alteran el flujo de la ejecución del
programa, pero recuerda que las sentencias dentro de una función no son
ejecutadas hasta que se llama a esa función.

Una llamada a una función es como un desvío en el flujo de la ejecución. En vez
de pasar a la siguiente sentencia, el flujo salta al cuerpo de
la función, ejecuta todas las sentencias que hay allí, y después vuelve
al punto donde lo dejó.

Todo esto parece bastante sencillo, hasta que uno recuerda que una función puede
llamar a otra. Cuando está en mitad de una función, el programa puede
tener que ejecutar las sentencias de otra función. Pero cuando
está ejecutando esa nueva función, ¡tal vez haya que ejecutar
todavía más funciones!

Afortunadamente, Python es capaz de llevar el seguimiento de dónde se encuentra en cada momento, de modo
que cada vez que completa la ejecución de una función, el programa vuelve al punto donde lo dejó
en la función que había llamado a esa. Cuando esto le lleva hasta el final del programa,
simplemente termina.

¿Cuál es la moraleja de esta sórdida historia? Cuando leas un programa, no
siempre te convendrá hacerlo de arriba a abajo. A veces tiene más
sentido seguir el flujo de la ejecución.

\section{Parámetros y argumentos}
\label{parameters}
\index{parámetro}
\index{parámetro!de función}
\index{argumento}
\index{argumento de función}

Algunas de las funciones internas que hemos visto necesitan argumentos. Por
ejemplo, cuando se llama a {\tt math.sin}, se le pasa un número
como argumento. Algunas funciones necesitan más de un argumento:
{\tt math.pow} toma dos, la base y el exponente.

Dentro de las funciones, los argumentos son asignados a
variables llamadas {\bf parámetros}. A continuación mostramos un ejemplo
de una función definida por el usuario que recibe un argumento:

\index{paréntesis!parámetros entre}

\beforeverb
\begin{verbatim}
def muestra_dos_veces(bruce):
    print bruce
    print bruce
\end{verbatim}
\afterverb
%
Esta función asigna el argumento a un parámetro
llamado {\tt bruce}. Cuando la función es llamada, imprime el valor del
parámetro (sea éste lo que sea) dos veces.

Esta función funciona con cualquier valor que pueda ser mostrado en pantalla.

\beforeverb
\begin{verbatim}
>>> muestra_dos_veces('Spam')
Spam
Spam
>>> muestra_dos_veces(17)
17
17
>>> muestra_dos_veces(math.pi)
3.14159265359
3.14159265359
\end{verbatim}
\afterverb
%
Las mismas reglas de composición que se aplican a las funciones internas, también
se aplican a las funciones definidas por el usuario, de modo que podemos usar cualquier tipo
de expresión como argumento para \verb"muestra_dos_veces":

\index{composición}

\beforeverb
\begin{verbatim}
>>> muestra_dos_veces('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam
>>> muestra_dos_veces(math.cos(math.pi))
-1.0
-1.0
\end{verbatim}
\afterverb
%
El argumento es evaluado antes de que la función sea llamada, así
que en los ejemplos, la expresión \verb"'Spam '*4" y
{\tt math.cos(math.pi)} son evaluadas sólo una vez.

\index{argumento}

También se puede usar una variable como argumento:

\beforeverb
\begin{verbatim}
>>> michael = 'Eric, la medio-abeja.'
>>> muestra_dos_veces(michael)
Eric, la medio-abeja.
Eric, la medio-abeja.
\end{verbatim}
\afterverb
%
El nombre de la variable que pasamos como argumento, ({\tt michael}) no
tiene nada que ver con el nombre del parámetro ({\tt bruce}). No
importa cómo se haya llamado al valor en origen (en la llamada);
dentro de \verb"muestra_dos_veces", siempre se llamará {\tt bruce}.

\section{Funciones productivas y funciones estériles}

\index{productiva, función}
\index{estéril, función}
\index{función productiva}
\index{función esteril} 

Algunas de las funciones que estamos usando, como las matemáticas, producen
resultados; a falta de un nombre mejor, las llamaremos {\bf funciones productivas} (fruitful functions).
Otras funciones, como \verb"muestra_dos_veces", realizan una
acción, pero no devuelven un valor. A esas las llamaremos {\bf funciones
estériles} (void functions).

Cuando llamas a una función productiva, casi siempre
querrás hacer luego algo con el resultado; por ejemplo, puede
que quieras asignarlo a una variable o usarlo como parte de una expresión:

\beforeverb
\begin{verbatim}
x = math.cos(radians)
aurea = (math.sqrt(5) + 1) / 2
\end{verbatim}
\afterverb
%
Cuando llamas a una función en modo interactivo, Python muestra
el resultado:

\beforeverb
\begin{verbatim}
>>> math.sqrt(5)
2.2360679774997898
\end{verbatim}
\afterverb
%
Pero en un script, si llamas a una función productiva y no
almacenas el resultado de la misma en una variable,
¡el valor de retorno se desvanece en la niebla!

\beforeverb
\begin{verbatim}
math.sqrt(5)
\end{verbatim}
\afterverb
%
Este script calcula la raíz cuadrada de 5, pero dado que no almacena
el resultado en una variable ni lo muestra, no resulta en realidad muy útil.

\index{interactivo, modo}
\index{script, modo}

Las funciones estériles pueden mostrar algo en la pantalla o tener cualquier
otro efecto, pero no devuelven un valor. Si intentas asignar
el resultado a una variable, obtendrás un valor especial llamado
{\tt None} (nada).

\index{None, valor especial}
\index{valor especial!None}

\beforeverb
\begin{verbatim}
>>> resultado = print_twice('Bing')
Bing
Bing
>>> print resultado
None
\end{verbatim}
\afterverb
%
El valor {\tt None} no es el mismo que la cadena \verb"'None'".
Es un valor especial que tiene su propio tipo:

\beforeverb
\begin{verbatim}
>>> print type(None)
<type 'NoneType'>
\end{verbatim}
\afterverb
%
Para devolver un resultado desde una función, usamos la sentencia {\tt return}
dentro de ella. Por ejemplo, podemos crear una función
muy simple llamada {\tt sumados},
que suma dos números y devuelve el resultado.

\beforeverb
\begin{verbatim}
def sumados(a, b):
    suma = a + b
    return suma

x = sumados(3, 5)
print x
\end{verbatim}
\afterverb
%
Cuando se ejecuta este script, la sentencia {\tt print} mostrará ``8'',
ya que la función {\tt sumados} ha sido llamada con 3 y 5 como argumentos.
Dentro de la función, los parámetros {\tt a} y {\tt b} equivaldrán a 3 y a 5
respectivamente. La función calculó la suma de ambos número y la guardó
en una variable local a la función llamada {\tt suma}.
Después usó la sentencia {\tt return}
para enviar el valor calculado de vuelta al código de llamada
como resultado de la función, que fue asignado
a la variable {\tt x} y mostrado en pantalla.

\section{¿Por qué funciones?}
\index{función, razones para}

Puede no estar muy claro por qué merece la pena molestarse en dividir
un programa en funciones. Existen varias razones:

\begin{itemize}

\item El crear una función nueva te da oportunidad de dar nombre a un grupo
de sentencias, lo cual hace a tu programa más fácil de leer, entender,
y depurar.

\item Las funciones pueden hacer un programa más pequeño, al eliminar código
repetido. Además, si quieres realizar cualquier cambio en el futuro, sólo tendrás
que hacerlo en un único lugar.

\item Dividir un programa largo en funciones te permite depurar las
partes de una en una y luego ensamblarlas juntas en una sola pieza.

\item Las funciones bien diseñadas a menudo resultan útiles para otros muchos programas.
Una vez que has escrito y depurado una, puedes reutilizarla.

\end{itemize}

A lo largo del resto del libro, a menudo usaremos una definición de función para
explicar un concepto. Parte de la habilidad de crear y usar funciones consiste en llegar a
tener una función que capture correctamente una idea, como ``encontrar el valor
más pequeño en una lista de valores''. Más adelante te mostraremos el código para
encontrar el valor más pequeño de una lista de valores y te lo presentaremos como
una función llamada {\tt min}, que toma una lista de valores como argumento y
devuelve el menor valor de esa lista.


\section{Depuración}
\label{editor}
\index{depuración}

Si estás usando un editor de texto para escribir tus propios scripts, puede
que tengas problemas con los espacios y tabulaciones. El mejor modo de evitar
esos problemas es usar espacios exclusivamente (no tabulaciones). La mayoría
de los editores de texto que reconocen Python lo hacen así por defecto, aunque
hay algunos que no.

\index{espacio en blanco}

Las tabulaciones y los espacios normalmente son invisibles, lo cual hace
que sea difícil depurar los errores que se pueden producir, así que mejor
busca un editor que gestione el indentado por ti.

Tampoco te olvides de guardar tu programa antes de hacerlo funcionar. Algunos
entornos de desarrollo lo hacen automáticamente, pero otros no.
En ese caso, el programa que estás viendo en el editor de texto
puede no ser el mismo que estás ejecutando en realidad.

¡La depuración puede llevar mucho tiempo si estás haciendo funcionar el
mismo programa con errores una y otra vez!

Asegúrate que el código que estás examinando es el mismo que estás ejecutando.
Si no estás seguro, pon algo como \verb"print 'hola'" al principio
del programa y hazlo funcionar de nuevo. Si no ves \verb"hola" en la
pantalla, ¡es que no estás ejecutando el programa correcto!


\section{Glosario}

\begin{description}

\item[algoritmo:] Un proceso general para resolver una categoría de problemas.
\index{algoritmo}

\item[argumento:] Un valor proporcionado a una función cuando ésta es llamada.
Ese valor se asigna al parámetro correspondiente en la función.
\index{argumento}

\item[cabecera:] La primera línea de una definición de función.
\index{cabecera}

\item[cuerpo:] La secuencia de sentencias dentro de la definición de una función.
\index{cuerpo}

\item[composición:] Uso de una expresión o sentencia como parte de otra más larga,
\index{composición}

\item[definición de función:] Una sentencia que crea una función nueva,
especificando su nombre, parámetros, y las sentencias que ejecuta.
\index{función, definición}

\item[determinístico:] Perteneciente a un programa que hace lo mismo
cada vez que se ejecuta, a partir de las mismas entradas.
\index{determinístico}

\item[función:] Una secuencia de sentencias con un nombre que realizan alguna
operación útil. Las funciones pueden tomar argumentos o no, y pueden
producir un resultado o no.
\index{función}

\item[función productiva (fruitful function):] Una función que devuelve un valor.
\index{productiva, función}

\item[función estéril (void function):] Una función que no devuelve ningún valor.
\index{estéril, función}

\item[flujo de ejecución:] El orden en el cual se ejecutan las sentencias durante
el funcionamiento de un programa.
\index{flujo de ejecución}

\item[llamada a función:] Una sentencia que ejecuta una función. Consiste en
el nombre de la función seguido por una lista de argumentos.
\index{función, llamada a}

\item[notación punto:] La sintaxis para llamar a una función de
otro módulo, especificando el nombre del módulo seguido por un punto y el
nombre de la función.
\index{punto, notación}

\item[objeto función:]  Un valor creado por una definición de función.
El nombre de la función es una variable que se refiere al objeto
función.
\index{función, definición}

\item[objeto módulo:] Un valor creado por una sentencia {\tt import},
que proporciona acceso a los datos y código definidos en un módulo.
\index{módulo}

\item[parámetro:] Un nombre usado dentro de una función para referirse al valor
pasado como argumento.
\index{parámetro}

\item[pseudoaleatorio:] Perteneciente a una secuencia de números que parecen
ser aleatorios, pero son generados por un programa determinista.
\index{pseudoaleatorio}

\item[sentencia import:] Una sentencia que lee un archivo módulo y crea
un objeto módulo.
\index{import, sentencia}
\index{sentencia!import}

\item[valor de retorno:] El resultado de una función. Si una llamada a una función
es usada como una expresión, el valor de retorno es el valor de la expresión.
\index{valor de retorno}

\end{description}


\section{Ejercicios}

\begin{ex}
¿Cuál es la utilidad de la palabra clave ``def'' en Python?

a) Es una jerga que significa ``este código es realmente estupendo''\\
b) Indica el comienzo de una función\\
c) Indica que la siguiente sección de código indentado debe ser almacenada para usarla más tarde\\
d) b y c son correctas ambas\\
e) Ninguna de las anteriores
\end{ex}

\begin{ex}
¿Qué mostrará en pantalla en siguiente programa Python?

\beforeverb
\begin{verbatim}
def fred():
   print "Zap"

def jane():
   print "ABC"

jane()
fred()
jane()
\end{verbatim}
\afterverb
%
a) Zap ABC jane fred jane\\
b) Zap ABC Zap\\
c) ABC Zap jane\\
d) ABC Zap ABC\\
e) Zap Zap Zap
\end{ex}

\begin{ex}
Reescribe el programa de cálculo del salario, con tarifa-y-media para las horas extras,
y crea una función llamada \verb"calculo_salario" que reciba
dos parámetros ({\tt horas} y {\tt tarifa}).

\begin{verbatim}
Introduzca Horas: 45
Introduzca Tarifa: 10
Salario: 475.0
\end{verbatim}
\end{ex}

\begin{ex}
Reescribe el programa de calificaciones del capítulo anterior
usando una función llamada \verb"calcula_calificacion", que reciba
una puntuación como parámetro y devuelva una calificación como cadena.

\begin{verbatim}
Puntuación Calificación
> 0.9      Sobresaliente
> 0.8      Notable
> 0.7      Bien
> 0.6      Suficiente
<= 0.6     Insuficiente

Ejecución del programa:

Introduzca puntuación: 0.95
Sobresaliente

Introduzca puntuación: perfecto
Puntuación incorrecta

Introduzca puntuación: 10.0
Puntuación incorrecta

Introduzca puntuación: 0.75
Bien

Introduzca puntuación: 0.5
Insuficiente
\end{verbatim}

Ejecuta el programa repetidamente para probar con varios valores
de entrada diferentes.
\end{ex}