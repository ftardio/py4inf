% LaTeX source for ``Python for Informatics: Exploring Information''
% Copyright (c)  2010-  Charles R. Severance, All Rights Reserved

\chapter{Listas}

\index{list}
\index{type!list}


\section{Una lista es una secuencia}

Al igual que una cadena, una {\bf lista} es una secuencia de valores. En una cadena, los
valores son caracteres; en una lista, pueden ser de cualquier tipo. Los valores en las
listas reciben el nombre de {\bf elementos}, o a veces {\bf artículos}.

\index{element}
\index{sequence}
\index{item}

Hay varios modos de crear una lista nueva; el más simple
consiste en encerrar los elementos entre corchetes (\verb"[" y \verb"]"):

\beforeverb
\begin{verbatim}
[10, 20, 30, 40]
['rana crujiente', 'carnero vejiga', 'alondra vómito']
\end{verbatim}
\afterverb
%
El primer ejemplo es una lista de cuatro enteros. El segundo es una lista
de tres cadenas. Los elementos en una lista no tienen por qué ser todos del mismo tipo.
La lista siguiente contiene una cadena, un flotante, un entero y
(¡ahí va!) otra lista:

\beforeverb
\begin{verbatim}
['spam', 2.0, 5, [10, 20]]
\end{verbatim}
\afterverb
%
Una lista dentro de otra se dice que está {\bf anidada}.

\index{nested list}
\index{list!nested}

Una lista que no contiene elementos recibe el nombre
de lista vacía; se puede crear una simplemente
con unos corchetes vacíos, \verb"[]".

\index{empty list}
\index{list!empty}

Como se podría esperar, puedes asignar listas de valores a variables:

\beforeverb
\begin{verbatim}
>>> quesos = ['Cheddar', 'Edam', 'Gouda']
>>> numeros = [17, 123]
>>> vacia = []
>>> print quesos, numeros, vacio
['Cheddar', 'Edam', 'Gouda'] [17, 123] []
\end{verbatim}
\afterverb
%

\index{assignment}

\section{Las listas son mutables}

\index{list!element}
\index{access}
\index{index}
\index{bracket operator}
\index{operator!bracket}

La sintaxis para acceder a los elementos de una lista es la misma que
para acceder a los caracteres de una cadena---el operador corchete. La
expresión dentro de los corchetes especifica el índice. Recuerda que los
índices comienzan por 0:

\beforeverb
\begin{verbatim}
>>> print cheeses[0]
Cheddar
\end{verbatim}
\afterverb
%
A diferencia de las cadenas, las listas son mutables (pueden mutar), porque puedes cambiar el orden
de los elementos o reasignar un elemento dentro de la lista.
Cuando el operador corchete aparece en el lado izquierdo de una asignación,
éste identifica el elemento de la lista que será asignado.

\index{mutability}

\beforeverb
\begin{verbatim}
>>> numeros = [17, 123]
>>> numeros[1] = 5
>>> print numeros
[17, 5]
\end{verbatim}
\afterverb
%
El elemento cuyo índice es uno de {\tt numeros}, que
antes era 123, es ahora 5.

\index{index!starting at zero}
\index{zero, index starting at}

Puedes pensar en una lista como una relación entre índices y
elementos. Esta relación recibe el nombre de {\bf mapeo o direccionamiento}; cada índice
``dirige a'' uno de los elementos.
 

\index{item assignment}
\index{assignment!item}

Los índices de una lista funcionan del mismo modo que los índices de una cadena:

\begin{itemize}

\item Cualquier expresión entera puede ser utilizada como índice.

\item Si se intenta leer o escribir un elemento que no existe,
se obtiene un {\tt IndexError}.

\index{exception!IndexError}
\index{IndexError}

\item Si un índice tiene un valor negativo, contará hacia atrás desde
el final de la lista.

\end{itemize}

\index{list!index}


\index{list!membership}
\index{membership!list}
\index{in operator}
\index{operator!in}

El operador {\tt in} también funciona con las listas.

\beforeverb
\begin{verbatim}
>>> quesos = ['Cheddar', 'Edam', 'Gouda']
>>> 'Edam' in quesos
True
>>> 'Brie' in quesos
False
\end{verbatim}
\afterverb


\section{Recorriendo una lista}
\index{list!traversal}
\index{traversal!list}
\index{for loop}
\index{loop!for}
\index{statement!for}

El modo más habitual de recorrer los elementos de una lista es
con un bucle {\tt for}. La sintaxis es la misma que para las cadenas:

\beforeverb
\begin{verbatim}
for queso in quesos:
    print queso
\end{verbatim}
\afterverb
%
Esto funciona correctamente si sólo se necesita leer los elementos de la
lista. Pero si quieres escribir o modificar los elementos,
se hacen necesarios los índices. Un modo habitual de hacerlo consiste en combinar
las funciones {\tt range} y {\tt len}:

\index{looping!with indices}
\index{index!looping with}

\beforeverb
\begin{verbatim}
for i in range(len(numeros)):
    numeros[i] = numeros[i] * 2
\end{verbatim}
\afterverb
%
Este bucle recorre la lista y actualiza cada elemento. {\tt len}
devuelve el número de elementos de la lista. {\tt range} devuelve
una lista de índices desde 0 hasta $n-1$, donde $n$ es la longitud de
la lista. Cada vez que atravesamos el bucle, {\tt i} obtiene el índice
del elemento siguiente. La sentencia de asignación en el cuerpo usa
{\tt i} para leer el valor anterior del elemento y asignarle el
valor nuevo.

\index{item update}
\index{update!item}

Un bucle {\tt for} aplicado a una lista vacía no ejecuta nunca el código contenido en su cuerpo:

\beforeverb
\begin{verbatim}
for x in vacia:
    print 'Esto nunca ocurrirá.'
\end{verbatim}
\afterverb
%
A pesar de que una lista puede contener otra, la lista
anidada sólo cuenta como un único elemento. La longitud de esta lista
es cuatro:

\index{nested list}
\index{list!nested}

\beforeverb
\begin{verbatim}
['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
\end{verbatim}
\afterverb



\section{Operaciones con listas}
\index{list!operation}

El operador {\tt +} concatena listas:

\index{concatenation!list}
\index{list!concatenation}

\beforeverb
\begin{verbatim}
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print c
[1, 2, 3, 4, 5, 6]
\end{verbatim}
\afterverb
%
De forma similar, el operador {\tt *} repite una lista el número especificado de veces:

\index{repetition!list}
\index{list!repetition}

\beforeverb
\begin{verbatim}
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
\end{verbatim}
\afterverb
%
El primer ejemplo repite {\tt [0]} cuatro veces. El segundo,
repite la lista {\tt [1, 2, 3]} tres veces.


\section{Rebanado de listas}

\index{slice operator}
\index{operator!slice}
\index{index!slice}
\index{list!slice}
\index{slice!list}

El operador de recorte o rebanado también funciona en listas:

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3]
['b', 'c']
>>> t[:4]
['a', 'b', 'c', 'd']
>>> t[3:]
['d', 'e', 'f']
\end{verbatim}
\afterverb
%
Si omites el primer índice, la rebanada comenzará al principio.
Si omites el segundo, la rebanada llegará hasta el final. De modo que
si omites ambos, la rebanada será una copia de la lista completa.

\index{list!copy}
\index{slice!copy}
\index{copy!slice}

\beforeverb
\begin{verbatim}
>>> t[:]
['a', 'b', 'c', 'd', 'e', 'f']
\end{verbatim}
\afterverb
%
Como las litas son mutables, a menudo resultará útil hacer una copia
antes de realizar operaciones que dupliquen elementos, revuelvan o mutilen
listas.

\index{mutability}

Un operador de rebanado en la parte izquierda de una asignación
puede modificar múltiples elementos:

\index{slice!update}
\index{update!slice}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3] = ['x', 'y']
>>> print t
['a', 'x', 'y', 'd', 'e', 'f']
\end{verbatim}
\afterverb
%

\section{Métodos de listas}

\index{list!method}
\index{method, list}

Python proporciona varios métodos que operan con listas. Por ejemplo,
{\tt append} añade un nuevo elemento al final de una lista:

\index{append method}
\index{method!append}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> t.append('d')
>>> print t
['a', 'b', 'c', 'd']
\end{verbatim}
\afterverb
%
{\tt extend} toma una lista como argumento y añade al final de la actual
todos sus elementos

\index{extend method}
\index{method!extend}

\beforeverb
\begin{verbatim}
>>> t1 = ['a', 'b', 'c']
>>> t2 = ['d', 'e']
>>> t1.extend(t2)
>>> print t1
['a', 'b', 'c', 'd', 'e']
\end{verbatim}
\afterverb
%
En este ejemplo, {\tt t2} no se modifica.

{\tt sort} ordena los elementos de una lista de menor a mayor:

\index{sort method}
\index{method!sort}

\beforeverb
\begin{verbatim}
>>> t = ['d', 'c', 'e', 'b', 'a']
>>> t.sort()
>>> print t
['a', 'b', 'c', 'd', 'e']
\end{verbatim}
\afterverb
%
La mayoría de los métodos de lista no devuelven nada; modican la lista y devuelven {\tt None}.
Si escribes por accidente {\tt t = t.sort()}, seguro que te sientes defraudado
por el resultado.

\index{void method}
\index{method!void}
\index{None special value}
\index{special value!None}

\section{Borrando elementos}

\index{element deletion}
\index{deletion, element of list}

Hay varias formas de borrar elementos de una lista. Si conoces
el índice del elemento que quieres eliminar, puedes usar
{\tt pop}:

\index{pop method}
\index{method!pop}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> x = t.pop(1)
>>> print t
['a', 'c']
>>> print x
b
\end{verbatim}
\afterverb
%
{\tt pop} modifica la lista y devuelve el elemento que ha sido eliminado.
Si no le proporcionas un índice, borra y devuelve el
último elemento.

Si no necesitas el valor eliminado, puedes usar el operador
{\tt del}:

\index{del operator}
\index{operator!del}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> del t[1]
>>> print t
['a', 'c']
\end{verbatim}
\afterverb
%

Si conoces el elemento que quieres eliminar (pero no su índice), puedes
usar {\tt remove}:

\index{remove method}
\index{method!remove}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> t.remove('b')
>>> print t
['a', 'c']
\end{verbatim}
\afterverb
%
El valor que devuelve {\tt remove} es {\tt None}.

\index{None special value}
\index{special value!None}

Para eliminar más de un elemento, puedes usar {\tt del} con
un índice de rebanada:

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del t[1:5]
>>> print t
['a', 'f']
\end{verbatim}
\afterverb
%
Como de costumbre, el método de rebanado selecciona todos los elementos hasta, pero
no incluyendo, el segundo índice.

\section{Listas y funciones}

Hay un número de funciones incorporadas que pueden utilizarse en las listas
y que nos permiten buscar rápidamente a través de una lista
sin tener que escribir nuestros propios bucles:

\beforeverb
\begin{verbatim}
>>> nums = [3, 41, 12, 9, 74, 15]
>>> print len(nums)
6
>>> print max(nums)
74
>>> print min(nums)
3
>>> print sum(nums)
154
>>> print sum(nums)/len(nums)
25
\end{verbatim}
\afterverb
%
La función {\tt sum()} solamente funciona cuando los elementos de la lista son números.
Las otras funciones ({\tt max()}, {\tt len()}, etc.) funcionan también con listas
de cadenas y otros tipos que se puedan comparar.

Podemos reescribir un programa anterior que calculaba la media de
varios números introducidos por el usuario, usando ahora una lista.

Primero, el programa que calculaba la media sin usar listas:

\beforeverb
\begin{verbatim}
total = 0
cuenta = 0
while ( True ) :
    ent = raw_input('Introduzce un número: ')
    if ent == 'fin' : break
    valor = float(ent)
    total = total + valor
    cuenta = cuenta + 1

media = total / cuenta
print 'Media:', media
\end{verbatim}
\afterverb
%
En este programa, tenemos las variables {\tt cuenta} y {\tt total}
para almacenar la cantidad y el total actual de los números del usuario
según éste los va introduciendo.

Podemos simplemente guardar cada número que el usuario introduzca
y usar las funciones incorporadas para calcular la suma y la cantidad
de números al final.

\beforeverb
\begin{verbatim}
listnum = list()
while ( True ) :
    ent = raw_input('Introduce un número: ')
    if ent == 'fin' : break
    valor = float(ent)
    listnum.append(valor)

media = sum(listnum) / len(listnum)
print 'Media:', media
\end{verbatim}
\afterverb
%
Creamos una lista vacía antes de que el bucle comience, y luego cada vez
que tenemos un número lo añadimos a la lista. Al final del
programa, simplemente calculamos la suma de los números de la
lista y lo dividimos por la cantidad de números,
para conseguir la media.

\section{Listas y cadenas}

\index{list}
\index{string}
\index{sequence}

Una cadena es una secuencia de caracteres y una lista es una secuencia
de valores, pero una lista de caracteres no es lo mismo que una
cadena. Para convertir desde una cadena a una lista de caracteres,
se puede usar la función {\tt list}:

\index{list!function}
\index{function!list}

\beforeverb
\begin{verbatim}
>>> s = 'spam'
>>> t = list(s)
>>> print t
['s', 'p', 'a', 'm']
\end{verbatim}
\afterverb
%
Debido a que {\tt list} es el nombre de una función incorporada, debes
evitar usarla como nombre de variable. Yo también evito utilizar la letra {\tt l},
porque se parece mucho al número {\tt 1}. Por eso utilizo {\tt t}.

La función {\tt list} divide una cadena en letras individuales. Si
quieres dividir una cadena en palabras, puedes usar el método
{\tt split}:

\index{split method}
\index{method!split}

\beforeverb
\begin{verbatim}
>>> s = 'suspirando por los fiordos'
>>> t = s.split()
>>> print t
['suspirando', 'por', 'los', 'fiordos']
>>> print t[2]
the
\end{verbatim}
\afterverb
%
Una vez hayas usado {\tt split} para dividir la cadena
en una lista de palabras, se puede utilizar el operador índice
(corchetes) para buscar una palabra concreta en la lista.

Puedes llamar a {\tt split} con
un argumento opcional llamado {\bf delimitador}, que
especifica qué caracteres se deben usar como delimitadores de palabras.
El ejemplo siguiente usa un guión como delimitador:

\index{optional argument}
\index{argument!optional}
\index{delimiter}

\beforeverb
\begin{verbatim}
>>> s = 'spam-spam-spam'
>>> delimitador = '-'
>>> s.split(delimitador)
['spam', 'spam', 'spam']
\end{verbatim}
\afterverb
%
{\tt join} es la inversa de {\tt split}. Toma
una lista de cadenas y
concatena sus elementos. {\tt join} es un método de cadena,
de modo que debes invocarlo sobre el delimitador y pasarle
la lista como un parámetro:

\index{join method}
\index{method!join}
\index{concatenation}

\beforeverb
\begin{verbatim}
>>> t = ['suspirando', 'por', 'los', 'fiordos']
>>> delimitador = ' '
>>> delimitador.join(t)
'suspirando por los fiordos'
\end{verbatim}
\afterverb
%
En caso de que el delimitador sea el carácter espacio,
entonces {\tt join} coloca un espacio entre las palabras. Para concatenar
cadenas sin espacios, puedes usar la cadena vacía,
\verb"''", como delimitador.

\index{empty string}
\index{string!empty}


\section{Analizando líneas}

Normalmente, cuando se está leyendo un archivo,
se deseará hacer con las líneas algo más que simplemente
imprimirlas completas en pantalla. A menudo se querrán encontrar
las ``líneas interesantes'' y luego {\bf analizar} cada una de ellas
para buscar alguna \emph{parte} importante en su interior. ¿Qué ocurre si queremos
imprimir el día de la semana de aquellas líneas que comienzan por ``From ''?

\beforeverb
\begin{alltt}
From stephen.marquard@uct.ac.za {\bf Sat} Jan  5 09:14:16 2008
\end{alltt}
\afterverb

El método {\tt split} es muy efectivo cuando nos enfrentamos con este
tipo de problemas.
Podemos escribir un pequeño programa que busque las líneas que
comiencen por ``From '', extraer las palabras de esas líneas con {\tt split},
y luego imprimir en pantalla la tercera palabra de cada una:

\beforeverb
\begin{verbatim}
fman = open('mbox-short.txt')
for linea in fman:
    linea = linea.rstrip()
    if not linea.startswith('From ') : continue
    palabras = linea.split()
    print palabras[2]
\end{verbatim}
\afterverb
%
Aquí utilizamos también la forma contraída de la sentencia
{\tt if}, de modo que colocamos el {\tt continue} en la
misma línea que el {\tt if}. Esta forma contraída
del {\tt if} opera igual que cuando el
{\tt continue} se coloca en la siguiente línea y sangrado.

El programa produce la siguiente salida:

\beforeverb
\begin{verbatim}
Sat
Fri
Fri
Fri
    ...
\end{verbatim}
\afterverb
%
Más adelante, aprenderemos técnicas más sofisticadas para
seleccionar las líneas con las que vamos a trabajar y veremos cómo extraer
esas líneas para encontrar el trozo exacto de información
que estamos buscando.

\section{Objetos y valores}

\index{object}
\index{value}

Si ejecutamos estas sentencias de asignación:

\beforeverb
\begin{verbatim}
a = 'banana'
b = 'banana'
\end{verbatim}
\afterverb
%
sabemos que {\tt a} y {\tt b} se refieren ambas a una
cadena, pero no sabemos si se refieren a la
\emph{misma} cadena. Hay dos estados posibles:

\index{aliasing}

\beforefig
\centerline{\includegraphics{figs2/list1.eps}}
\afterfig

En el primer caso, {\tt a} y {\tt b} se refieren a dos objetos diferentes que
tienen el mismo valor. En el segundo, se refieren al mismo
objeto.

\index{is operator}
\index{operator!is}

Para comprobar si dos variables se refieren al mismo objeto, puedes
usar el operador {\tt is}.

\beforeverb
\begin{verbatim}
>>> a = 'banana'
>>> b = 'banana'
>>> a is b
True
\end{verbatim}
\afterverb
%
En este ejemplo, Python sólo crea un objeto cadena,
y tanto {\tt a} como {\tt b} se refieren a él.

Pero cuando creas dos listas, obtienes dos objetos:

\beforeverb
\begin{verbatim}
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
False
\end{verbatim}
\afterverb
%

En este caso podríamos decir que las dos listas son {\bf equivalentes},
porque tienen los mismos elementos, pero no son {\bf idénticas}, porque
no son el mismo objeto. Si dos objetos son idénticos, también
son equivalentes, pero si son equivalentes, no necesariamente
son idénticos.

\index{equivalence}
\index{identity}

Hasta ahora, hemos estado usando ``objeto'' y ``valor''
de forma intercambiable, pero es más preciso decir que un objeto tiene
un valor. Si ejecutas {\tt a = [1,2,3]}, {\tt a} se refiere a un objeto
lista cuyo valor es una secuencia particular de elementos. Si otra
lista tiene los mismos elementos, podemos decir que tiene el mismo valor.

\index{object}
\index{value}


\section{Alias}

\index{aliasing}
\index{reference!aliasing}

Si {\tt a} se refiere a un objeto y asignas {\tt b = a},
entonces ambas variables se refieren al mismo objeto:

\beforeverb
\begin{verbatim}
>>> a = [1, 2, 3]
>>> b = a
>>> b is a
True
\end{verbatim}
\afterverb
%

La asociación de una variable con un objeto recibe el nombre de
{\bf referencia}. En este ejemplo, hay dos referencias para el mismo
objeto.

\index{reference}

Un objeto con más de una referencia tiene más
de un nombre, de modo que decimos que el objeto tiene uno o varios {\bf alias}.

\index{mutability}

Si el objeto con alias es mutable,
los cambios que se hagan en uno de los alias
afectarán al otro:

\beforeverb
\begin{verbatim}
>>> b[0] = 17
>>> print a
[17, 2, 3]
\end{verbatim}
\afterverb
%
A pesar de que este comportamiento puede resultar útil, resulta también propenso a errores. En general,
resulta más seguro evitar usar alias cuando se está trabajando con objetos
mutables.

\index{immutability}

Para objetos inmutables, como cadenas, usar alias no resulta tan
problemático. En este ejemplo:

\beforeverb
\begin{verbatim}
a = 'banana'
b = 'banana'
\end{verbatim}
\afterverb
%
casi nunca importa si {\tt a} y {\tt b} se refieren
a la misma cadena o no.


\section{Listas como argumentos}

\index{list!as argument}
\index{argument}
\index{argument!list}
\index{reference}
\index{parameter}

Cuando se pasa una lista a una función, la función recibe una referencia
de esa lista.
Si la función modifica un parámetro de la lista, el código que la ha llamado también se verá afectado por el cambio.
Por ejemplo, \verb"borra_primero" elimina el primer elemento de una lista:

\beforeverb
\begin{verbatim}
def borra_primero(t):
    del t[0]
\end{verbatim}
\afterverb
%
He aquí cómo lo hemos usado:

\beforeverb
\begin{verbatim}
>>> letras = ['a', 'b', 'c']
>>> borra_primero(letras)
>>> print letras
['b', 'c']
\end{verbatim}
\afterverb
%
El parámetro {\tt t} y la variable {\tt letras} son
alias para el mismo objeto.

Resulta importante distinguir entre las operaciones que
modifican listas y las operaciones que crean listas nuevas.
Por ejemplo, el método {\tt append} modifica una lista, pero el
operador {\tt +} crea una lista nueva:

\index{append method}
\index{method!append}
\index{list!concatenation}
\index{concatenation!list}

\beforeverb
\begin{verbatim}
>>> t1 = [1, 2]
>>> t2 = t1.append(3)
>>> print t1
[1, 2, 3]
>>> print t2
None

>>> t3 = t1 + [3]
>>> print t3
[1, 2, 3]
>>> t2 is t3
False
\end{verbatim}
\afterverb

Esta diferencia es importante cuando se escriben funciones que
se supone que modificarán listas. Por ejemplo, esta función
\emph{no} borra el primer elemento de una lista:

\beforeverb
\begin{verbatim}
def no_borra_primero(t):
    t = t[1:]              # ¡INCORRECTO!
\end{verbatim}
\afterverb

El operador de rebanado crea una lista nueva y la asignación
hace que {\tt t} se refiera a ella, pero ninguno de ellos tiene ningún efecto
sobre la lista que se ha pasado como argumento.

\index{slice operator}
\index{operator!slice}

Una alternativa consiste en escribir una función que cree y
retorne una lista nueva. Por ejemplo,
{\tt cola} devuelve todos los elementos de la lista
excepto el primero:

\beforeverb
\begin{verbatim}
def cola(t):
    return t[1:]
\end{verbatim}
\afterverb
%
Esta función deja la lista original sin modificar.
Aquí está el modo como se usa:

\beforeverb
\begin{verbatim}
>>> letras = ['a', 'b', 'c']
>>> resto = cola(letras)
>>> print resto
['b', 'c']
\end{verbatim}
\afterverb


\begin{ex}

Escribe una función llamada {\tt recorta}, que tome una lista, la
modifique, eliminando los elementos primero y último, y devuelva {\tt None}.

Después escribe una función llamada {\tt centro}, que tome una lista y
devuelva otra que contenga todos los elementos de la original,
menos el primero y el último.

\end{ex}


\section{Depuración}
\index{debugging}

El uso descuidado de las listas (y otros objetos mutables)
puede ocasionar largas horas de depuración. He aquí algunas
trampas comunes y modos de evitarlas:

\begin{enumerate}

\item No olvides que la mayoría de los métodos de las listas modifican el argumento y
devuelven {\tt None}. Esto es lo opuesto a lo que hacen los métodos de cadena,
que devuelven una cadena nueva y dejan la original inalterada.

Si tienes costumbre de escribir código con cadenas como éste:

\beforeverb
\begin{verbatim}
palabra = palabra.strip()
\end{verbatim}
\afterverb

Resulta tentador escribir código con listas como éste:

\beforeverb
\begin{verbatim}
t = t.sort()           # ¡INCORRECTO!
\end{verbatim}
\afterverb

\index{sort method}
\index{method!sort}

Debido a que {\tt sort} devuelve {\tt None}, la operación
siguiente que realices con {\tt t} es probable que falle.

Antes de usar métodos de lista y operadores, deberías leer la
documentación con cuidado y luego probarlos en modo interactivo. Los
métodos y operadores que comparten listas con otras secuencias (como
cadenas) están documentados en
\url{https://docs.python.org/2/library/stdtypes.html#string-methods}.
Los métodos y operadores que sólo se pueden aplicar a secuencias mutables
están documentados en
\url{https://docs.python.org/2/library/stdtypes.html#mutable-sequence-types}.


\item Elige un método y ajústate a él.
\index{idiom}

Parte del problema con las listas es que hay demasiados
modos de hacer las cosas. Por ejemplo, para eliminar un elemento de
una lista, se puede usar {\tt pop}, {\tt remove}, {\tt del},
o incluso una asignación de rebanada.

Para añadir un elemento, se puede usar el método {\tt append} o
el operador {\tt +}. Pero no olvides que esto es correcto:

\beforeverb
\begin{verbatim}
t.append(x)
t = t + [x]
\end{verbatim}
\afterverb

Mientras que esto es incorrecto:

\beforeverb
\begin{verbatim}
t.append([x])          # ¡INCORRECTO!
t = t.append(x)        # ¡INCORRECTO!
t + [x]                # ¡INCORRECTO!
t = t + x              # ¡INCORRECTO!
\end{verbatim}
\afterverb

Prueba cada uno de estos ejemplos en modo interactivo para asegurarte
de que comprendes lo que hacen. Fíjate que sólo el último
causa un error en tiempo de ejecución; los otros tres son correctos sintácticamente, pero
no hacen lo que queremos.


\item Haz copias para evitar los alias.

\index{aliasing!copying to avoid}
\index{copy!to avoid aliasing}

Si quieres usar un método como {\tt sort}, que modifica
el argumento, pero necesitas también mantener la lista original,
puedes hacer una copia.

\beforeverb
\begin{verbatim}
orig = t[:]
t.sort()
\end{verbatim}
\afterverb

En este ejemplo, puedes usar también la función incorporada {\tt sorted},
que devuelve una nueva lista ordenada, y deja el original sin modificar.
Pero en ese caso, ¡recuerda no utilizar {\tt sorted} como nombre de
variable!

\item Listas, {\tt particiones} y archivos

Cuando leemos y analizamos archivos, hay muchas oportunidades
de encontrar entradas que pueden hacer fallar nuestro programa, de modo que
es una buena idea recurrir al uso del patrón {\bf guardián} cuando
estemos escribiendo programas que lean a través de un archivo
y busquen ``una aguja en el pajar''.

Vamos a revisar nuestro anterior programa que busca el día de la semana
en las líneas de un archivo:

\beforeverb
\begin{alltt}
From stephen.marquard@uct.ac.za {\bf Sat} Jan  5 09:14:16 2008
\end{alltt}
\afterverb

Dado que estamos partiendo esta línea en palabras, podemos apañarnos
con el uso de {\tt startswith} y simplemente revisar la
primera palabra de la línea para determinar si estamos interesados
en ella o no. Podemos usar {\tt continue} para saltar aquellas
líneas que no tengan ``From'' como primera palabra, como hacemos
a continuación:

\beforeverb
\begin{verbatim}
fman = open('mbox-short.txt')
for linea in fman:
    palabras = linea.split()
    if palabras[0] != 'From' : continue
    print palabras[2]
\end{verbatim}
\afterverb
%
Esto parece mucho más sencillo y ni siquiera tenemos que usar el
{\tt rstrip} para eliminar los saltos de línea al final de cada línea.
Pero, ¿es mejor hacerlo así?

\beforeverb
\begin{verbatim}
python search8.py 
Sat
Traceback (most recent call last):
  File "search8.py", line 5, in <module>
    if palabras[0] != 'From' : continue
IndexError: list index out of range
\end{verbatim}
\afterverb
%
Parece funcionar, y podemos ver el día de la primera línea
(Sat), pero luego el programa falla con un error y su traceback.
¿Qué es lo que ha ido mal? ¿Qué desastroso dato ha provocado que nuestro elegante,
ingenioso, y muy Pythónico programa haya fallado?

Puedes revisarlo durante largo rato y romperte la cabeza
con él, o pedir ayuda a alguien, pero la aproximación más
rápida e inteligente es añadir una sentencia {\tt print}. El mejor lugar
para situarla es justo antes de la línea en la que
falla el programa, e imprimir el dato que parecer ser el causante
del fallo.

Esa aproximación puede generar un montón de líneas en la salida, pero
al menos tendrás a mano inmediatamente alguna pista acerca
del problema. De modo que imprimiremos la variable
{\tt palabras} justo antes de la línea cinco. Incluso
añadiremos el prefijo ``Debug:'' a la línea, de modo que
podemos mantener nuestra salida normal separada de la de depuración:

\beforeverb
\begin{verbatim}
for linea in fman:
    palabras = linea.split()
    print 'Debug:', palabras
    if palabras[0] != 'From' : continue
    print palabras[2]
\end{verbatim}
\afterverb
%
Cuando hacemos funcionar el programa, un montón de texto de salida
desplaza la pantalla hasta arriba. Al final veremos nuestra salida
de depuración y el traceback, de modo que podremos saber qué
ha ocurrido justo antes de producirse el error.

\beforeverb
\begin{verbatim}
Debug: ['X-DSPAM-Confidence:', '0.8475']
Debug: ['X-DSPAM-Probability:', '0.0000']
Debug: []
Traceback (most recent call last):
  File "search9.py", line 6, in <module>
    if palabras[0] != 'From' : continue
IndexError: list index out of range
\end{verbatim}
\afterverb
%
Cada línea de depuración está imprimiendo la lista de palabras que obtenemos
cuando {\tt dividimos} la línea en palabras. Cuando el programa falla,
la lista de palabras está vacía \verb"[]". Si abrimos el archivo en un
editor de texto y observamos su contenido, en ese punto podemos ver
lo siguiente:

\beforeverb
\begin{verbatim}
X-DSPAM-Result: Innocent
X-DSPAM-Processed: Sat Jan  5 09:14:16 2008
X-DSPAM-Confidence: 0.8475
X-DSPAM-Probability: 0.0000

Details: http://source.sakaiproject.org/viewsvn/?view=rev&rev=39772
\end{verbatim}
\afterverb
%
¡El error se produce cuando nuestro programa encuentra una línea en blanco! Por supuesto,
hay ``cero palabras'' en una línea en blanco. ¿Por qué no hemos pensado en eso
cuando estábamos escribiendo el código? Cuando el código busca la primera
palabra (\verb"palabras[0]"), para comprobar si coincide con ``From'',
obtenemos un error ``index out of range (índice fuera de rango)''.

Por supuesto, éste es el lugar perfecto para añadir un código {\bf guardián},
que impida revisar la primera palabra si resulta que no existe primera palabra.
Hay muchos modos de proteger este código; vamos a optar por
comprobar el número de palabras que tenemos antes de mirar cuál es la primera palabra:

\beforeverb
\begin{verbatim}
fman = open('mbox-short.txt')
cuenta = 0
for linea in fman:
    palabras = linea.split()
    # print 'Debug:', palabras
    if len(palabras) == 0 : continue
    if palabras[0] != 'From' : continue
    print palabras[2]
\end{verbatim}
\afterverb
%
Primero hemos comentado la sentencia print de depuración en lugar de eliminarla,
para que si nuestra modificación falla podemos depurarlo de nuevo. Después, hemos añadido
una sentencia guardián que comprueba si tenemos cero palabras, y si es así,
usamos {\tt continue} para saltar a la siguiente línea del archivo. 

Podemos pensar en las dos sentencias {\tt continue} como ayudas para seleccionar
el conjunto de líneas que nos resultan ``interesantes'' y que querremos
procesar un poco más. Una línea que no tiene palabras resulta ``no-interesante'' para
nosotros, de modo que saltamos a la siguiente. Una línea que no tiene ``From''
como primera palabra tampoco resulta interesante para nosotros, así que también la saltaremos.

El programa modificado funciona correctamente, así que tal vez sea correcto. Nuestra
sentencia guardián nos asegura que {\tt palabras[0]} no fallará nunca,
pero tal vez eso no sea suficiente. Cuando estamos programando, siempre debemos
estar pensando: ``¿Qué podría ir mal?''

\begin{ex}

Averigua qué línea del programa anterior aún no está suficientemente protegida.
Mira a ver si puedes construir un archivo de texto que provoque que el programa falle,
luego modifica el programa para que esa línea quede protegida adecuadamente, y
pruébalo para asegurarte de que es capaz de manejar tu nuevo archivo de texto.

\end{ex}

\begin{ex}
Reescribe el código guardián en el ejemplo de arriba para que no use dos
sentencias {\tt if}. En su lugar, usa una expresión lógica compuesta, utilizando
el operador lógico {\tt and} en una única sentencia {\tt if}.
\end{ex}


\end{enumerate}



\section{Glosario}

\begin{description}

\item[alias:] Una circunstancia en la cual dos o más variables se refieren al mismo
objeto.
\index{aliasing}

\item[delimitador:] Un carácter o cadena usado para indicar por dónde
debe ser dividida una cadena.
\index{delimiter}

\item[elemento:] Uno de los valores en una lista (u otra secuencia);
también reciben el nombre de artículos.
\index{element}

\item[equivalentes:] Que tienen el mismo valor.
\index{equivalent}

\item[idénticos:] Que son el mismo objeto (lo cual implica equivalencia).
\index{identical}

\item[índice:] Un valor entero que indica un elemento concreto dentro de una lista.
\index{index}

\item[lista:] Una secuencia de valores.
\index{list}

\item[lista anidada:] Una lista que es un elemento de otra lista.
\index{nested list}

\item[objeto:] Algo a lo que se puede referir una variable. Un objeto
tiene un tipo y un valor.
\index{object}

\item[recorrido de una lista:] El acceso secuencial a cada elemento de una lista.
\index{list!traversal}

\item[referencia:] La asociación entre una variable y su valor.
\index{reference}

\end{description}


\section{Ejercicios}

\begin{ex}
Descarga una copia del fichero, desde
\url{www.py4inf.com/code/romeo.txt}
\index{Romeo and Juliet}

Escribe un programa que abra el archivo {\tt romeo.txt} y lo lea
línea a línea. Para cada línea, divídela en una lista de
palabras usando la función {\tt split}.

Para cada palabra, mira a ver si esa palabra ya existe en la lista.
Si no es así, añádela.

Cuando el programa finalice, ordena y muestra en pantalla las
palabras resultantes, en orden alfabético.

\begin{verbatim}
Introduce fichero: romeo.txt
['Arise', 'But', 'It', 'Juliet', 'Who', 'already', 
'and', 'breaks', 'east', 'envious', 'fair', 'grief', 
'is', 'kill', 'light', 'moon', 'pale', 'sick', 'soft', 
'sun', 'the', 'through', 'what', 'window', 
'with', 'yonder']
\end{verbatim}
\end{ex}

\begin{ex}
Escribe un programa que lea a través de los datos de un buzón de correo, y cuando
encuentre una línea que empiece por ``From'', la divida en
palabras usando la función {\tt split}. Estamos interesados en
quién nos envían el mensaje, que es la segunda palabra de la línea From.

{\tt From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008 }

Debes analizar la línea From y mostrar en pantalla la segunda palabra de
cada una de esas líneas, luego ir contabilizando también el número de líneas From
(no From:), y mostrar el total al final.

Este es un buen ejemplo de salida con algunas líneas eliminadas:

\beforeverb
\begin{verbatim}
python fromcount.py 
Introduce un nombre de archivo: mbox-short.txt
stephen.marquard@uct.ac.za
louis@media.berkeley.edu
zqian@umich.edu

[...parte de la salida eliminada...]

ray@media.berkeley.edu
cwen@iupui.edu
cwen@iupui.edu
cwen@iupui.edu
Hay 27 lines en el archivo con From como primera palabra
\end{verbatim}
\afterverb
%
\end{ex}

\begin{ex}
Reescribe el programa que pide al usuario una lista de números
e imprime en pantalla el máximo y mínimo de los números
introducidos al final, cuando el usuario introduce ``fin''.
Escribe ahora el programa de modo que almacene los números que el usuario
introduzca en una lista y use las funciones {\tt max()} y {\tt min()} para
calcular los números máximo y mínimo después de que el
bucle termine.

\beforeverb
\begin{verbatim}
Introduce un número: 6
Introduce un número: 2
Introduce un número: 9
Introduce un número: 3
Introduce un número: 5
Introduce un número: fin
Máximo: 9.0
Mínimo: 2.0
\end{verbatim}
\afterverb
%

\end{ex}

