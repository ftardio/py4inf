% LaTeX source for ``Python for Informatics: Exploring Information''
% Copyright (c)  2010-  Charles R. Severance, All Rights Reserved

\chapter{Ejecución condicional}

\section{Expresiones booleanas}
\index{boolean expression}
\index{expression!boolean}
\index{logical operator}
\index{operator!logical}

Una {\bf expresión booleana} es aquella que puede ser verdadera (true)
o falsa (false). Los ejemplos siguientes usan el operador
{\tt True} si son iguales y {\tt False} en caso contrario:

\beforeverb
\begin{verbatim}
>>> 5 == 5
True
>>> 5 == 6
False
\end{verbatim}
\afterverb
%
{\tt True} y {\tt False} son valores especiales
que pertenecen al tipo {\tt bool (booleano)}; no son cadenas:

\index{True special value}
\index{False special value}
\index{special value!True}
\index{special value!False}
\index{bool type}
\index{type!bool}

\beforeverb
\begin{verbatim}
>>> type(True)
<type 'bool'>
>>> type(False)
<type 'bool'>
\end{verbatim}
\afterverb
%
El perador {\tt ==} es uno de los {\bf operadores de comparación};
los demás son:

\beforeverb
\begin{verbatim}
      x != y               # x es distinto de y
      x > y                # x es mayor que y
      x < y                # x es menor que y
      x >= y               # x es mayor o igual que y
      x <= y               # x es menor o igual que y
      x is y               # x es lo mismo que y
      x is not y           # x no es lo mismo que y
\end{verbatim}
\afterverb
%
A pesar de que estas operaciones probablemente te resulten familiares, los
símboles en Python son diferentes de los símbolos matemáticos que se usan
para realizar las mismas operaciones. Un error muy común
es usar sólo un símbolo igual ({\tt =}) en vez del símbolo de doble igualdad
({\tt ==}). Recuerda que {\tt =} es el operador de asignación, y
{\tt ==} es un operador de comparación. No ocurre lo mismo con
{\tt =<} o {\tt =>}.

\index{comparison operator}
\index{operator!comparison}


\section {Operadores lógicos}
\index{logical operator}
\index{operator!logical}

Existen tres {\bf operadores lógicos}: {\tt and (y)}, {\tt
or (o)}, y {\tt not (no)}. La semántica (significado) de estas operaciones
es similar a su significado en inglés. Por ejemplo, 

{\tt x > 0 and x < 10} 

es verdadero sólo cuando {\tt x} es mayor que 0
\emph{y} menor que 10.

\index{and operator}
\index{or operator}
\index{not operator}
\index{operator!and}
\index{operator!or}
\index{operator!not}

{\tt n\%2 == 0 or n\%3 == 0} es verdadero si \emph{cualquiera} de las condiciones
es verdadera, es decir, el número es divisible por 2 \emph{o} por 3.

Finalmente, el operador {\tt not} niega una expresión
booleana, de modo que {\tt not (x > y)} es verdadero si {\tt x > y} es falso;
es decir, si {\tt x} es menor o igual que {\tt y}.

Estrictamente hablando, los operandos de los operadores lógicos deberían ser
expresiones booleanas, pero Python no es muy estricto.
Cualquier número distinto de cero se interpreta como ``verdadero.''

\beforeverb
\begin{verbatim}
>>> 17 and True
True
\end{verbatim}
\afterverb
%
Esta flexibilidad puede ser útil, pero existen ciertas sutilezas en
ello que pueden resultar confusas. Puede que quieras evitar usarlo así
hasta que estés bien seguro de lo que estás haciendo.

\section{Ejecución condicional}
\label{conditional execution}

\index{conditional statement}
\index{statement!conditional}
\index{if statement}
\index{statement!if}
\index{conditional execution}

Para poder escribir programas útiles, casi siempre vamos a necesitar
la capacidad de comprobar condiciones y cambiar el comportamiento del programa
de acuerdo a ellas. Las {\\ sentencias condicionales} nos proporciona esa capacidad.
La forma más sencilla es la sentencia {\\tt if}:

\beforeverb
\begin{verbatim}
if x > 0 :
    print 'x es positivo'
\end{verbatim}
\afterverb
%
La expresión booleana después de la sentencia {\\tt if} recibe
el nombre de {\bf condición}. La sentencia {\tt if} se termina
con un carácter de dos-puntos (:) y la(s) línea(s) que van detrás de
la sentencia if van sangradas (llevan una tabulación o varios espacios en blanco al principio).

\beforefig
\centerline{\includegraphics[height=1.75in]{figs2/if.eps}}
\afterfig

Si la condición lógica es verdadera, la sentencia sangrada
es ejecutada. Si la condición es falsa,
la sentencia sangrada es omitida.

\index{condition}
\index{compound statement}
\index{statement!compound}

La sentencia {\tt if} tiene la misma estructura que la definición de funciones
o los bucles {\tt for}\footnote{Estudiaremos las funciones en el capítulo 4
y los bucles en el capítulo 5.}. La sentencia consiste en una línea de encabezado
que termina con el carácter dos-puntos (:)
seguido por un bloque con sangrado. Las sentencias de este tipo
reciben el nombre de {\bf setentencias compuestas}, porque se extienden
a lo largo de varias líneas.

No hay límite en el número de sentencias que pueden aparecer en el
cuerpo, pero debe haber al menos una.
Ocasionalmente, puede resultar útil tener un cuerpo sin sentencias
(normalmente como emplazamiento reservado para código que no se ha escrito aún). En ese
caso, se puede usar la sentencia {\\tt pass}, que no hace nada.

\index{pass statement}
\index{statement!pass}

\beforeverb
\begin{verbatim}
if x < 0 :
    pass          # ¡necesito manejar los valores negativos!
\end{verbatim}
\afterverb
%
Si introduces una sentencia {\tt if} en el intérprete de Python, el prompt cambiará
su aspecto habitual por tres puntos, para indicar que estás en medio de un bloque de sentencias, como
se muestra a continuación:

\beforeverb
\begin{verbatim}
>>> x = 3
>>> if x < 10:
...    print 'Pequeño'
... 
Small
>>>
\end{verbatim}
\afterverb
%

\section{Ejecución alternativa}
\label{alternative execution}

\index{alternative execution}
\index{else keyword}
\index{keyword!else}

La segunda forma de la sentencia {\tt if} es la {\bf ejecución alternativa},
en la cual existen dos posibilidades y la condición determina
cual de ellas será ejecutada. La sintaxis se parece a esta:

\beforeverb
\begin{verbatim}
if x%2 == 0 :
    print 'x es par'
else :
    print 'x es impar'
\end{verbatim}
\afterverb
%
Si al dividir {\tt x} por 2 obtenemos como resto 0, entonces sabemos
que {\tt x} es par, y el programa muestra un mensaje a tal
efecto. Si esa condición es falsa, se ejecuta el segundo
conjunto de sentencias.

\beforefig
\centerline{\includegraphics[height=1.75in]{figs2/if-else.eps}}
\afterfig

Dado que la condición debe ser obligatoriamente o bien verdadera o bien falsa, solamente una de
las alternativas será ejecutada. Las alternativas reciben el nombre de
{\bf ramas}, dado que se trata de ramas en el flujo de la ejecución.

\index{branch}

\section{Condicionales encadenados}
\index{chained conditional}
\index{conditional!chained}

Algunas veces hay más de dos posibilidades, de modo que necesitamos más
de dos ramas. Una forma de expresar una computación como esa es usar un
{\bf condicional encadenado}:

\beforeverb
\begin{verbatim}
if x < y:
    print 'x es menor que y'
elif x > y:
    print 'x es mayor que y'
else:
    print 'x e y son iguales'
\end{verbatim}
\afterverb
%
{\tt elif} es una abreviatura para ``else if.''  En este caso también
será ejecutada únicamente una de las ramas.

\beforefig
\centerline{\includegraphics[height=3.00in]{figs2/elif.eps}}
\afterfig

No hay un límite para el número de sentencias
{\tt elif}. Si hay una claúsula {\tt else}, debe ir
al final, pero tampoco es obligatorio que ésta exista.

\index{elif keyword}
\index{keyword!elif}


\beforeverb
\begin{verbatim}
if choice == 'a':
    print 'Respuesta incorrecta'
elif choice == 'b':
    print 'Respuesta acertada'
elif choice == 'c':
    print 'Casi, pero no has acertado'
\end{verbatim}
\afterverb
%
Cada condición es comprobada en orden. Si la primera es falsa,
se comprueba la siguiente y así con las demás. Si una de ellas es
verdadera, se ejecuta la rama correspondiente, y la sentencia
termina. Incluso si hay más de una condición que sea verdadera, sólo se
ejecuta la primera que se encuentra.

\section{Condicionales anidados}
\index{nested conditional}
\index{conditional!nested}

Un condicional puede también estar anidado dentro de otro. Podríamos
haber escrito el anterior ejemplo de tres ramas de este modo:

\beforeverb
\begin{verbatim}
if x == y:
    print 'x e y son iguales'
else:
    if x < y:
        print 'x es menor que y'
    else:
        print 'x es mayor que y'
\end{verbatim}
\afterverb
%
El condicional exterior contiene dos ramas. La
primera rama ejecuta una sentencia simple. La segunda
contiene otra sentencia {\tt if}, que tiene a su vez sus propias
dos ramas. Esas dos ramas son ambas sentencias simples,
pero podrían haber sido sentencias condicionales también.

\beforefig
\centerline{\includegraphics[height=2.50in]{figs2/nested.eps}}
\afterfig

A pesar de que el sangrado de las sentencias hace que la estructura
esté clara, los {\bf condicionales anidados} pueden volverse difíciles
de leer enseguida. En general, es buena idea evitarlos si se puede.

Los operadores lógicos a menudo proporcionan un modo de simplificar las
sentencias condicionales anidadas. Por ejemplo, podemos reescribir el código
siguiente usando un único condicional:

\beforeverb
\begin{verbatim}
if 0 < x:
    if x < 10:
        print 'x es un número positivo con un sólo dígito.'
\end{verbatim}
\afterverb
%
La sentencia {\tt print} se ejecuta solamente si se pasa por los dos
condicionales, así que en realidad podemos conseguir el mismo efecto con el operador {\tt and}:

\beforeverb
\begin{verbatim}
if 0 < x and x < 10:
    print 'x es un número positivo con un sólo dígito.'
\end{verbatim}
\afterverb


\section{Capturando excepciones usando try y except}
\label{catch1}

Anteriormente vimos un fragmento de código donde usábamos las funciones \verb"raw_input" y
{\tt int} para leer y analizar un número entero introducido por
el usuario. También vimos lo poco seguro que podía llegar a ser hacer algo así:

\beforeverb
\begin{verbatim}
>>> velocidad = raw_input(prompt)
¿Cual.... es la velocidad aerodinámica de una golondrina sin carga?
¿Te refieres a una golondrina africana o a una europea?
>>> int(velocidad)
ValueError: invalid literal for int()
>>>
\end{verbatim}
\afterverb
%
Cuando estamos ejecutando este tipo de sentencias en el intérprete de Python,
sacamos un nuevo indicador del intérprete, pensamos ``oops'', y continuamos
con la siguiente sentencia.

Sin embargo, si pones ese código en un
script de Python y se produce el error, el script se detendrá
inmediatamente, y mostrará un ``traceback''.
No ejecutará la siguiente sentencia.

\index{traceback}

He aquí un programa de ejemplo para convertir una temperatura
desde grados Fahrenheit a grados Celsius:

\index{fahrenheit}
\index{celsius}
\index{temperature conversion}

\beforeverb
\begin{verbatim}
inp = raw_input('Introduce la Temperatura Fahrenheit:')
fahr = float(inp)
cel = (fahr - 32.0) * 5.0 / 9.0
print cel
\end{verbatim}
\afterverb
%
Si ejecutamos este código y le damos una entrada no válida, simplemente
fallará con un antipático mensaje de error:

\beforeverb
\begin{verbatim}
python fahren.py 
Enter Fahrenheit Temperature:72
22.2222222222

python fahren.py 
Introduce la Temperatura Fahrenheit:fred
Traceback (most recent call last):
  File "fahren.py", line 2, in <module>
    fahr = float(inp)
ValueError: invalid literal for float(): fred
\end{verbatim}
\afterverb
%
Existen estructuras de ejecución condicional dentro de
Python para manejar este tipo de errores esperados e
inesperados, llamadas ``try / except''. La idea de {\tt try}
y {\\ except} es que se sabe que cierta secuencia
de instrucciones pueden tener un problema y se quieren
añadir algunas sentencias para que sean ejecutadas si se produce un error.
Estas sentencias extras (el bloque except) serán ignoradas
si no hay ningún error.

Puedes pensar en la característica {\tt try} y {\tt except}
de Python como una ``póliza de seguros'' en una secuencia
de sentencias.

Se puede reescribir nuestro conversor de temperaturas del siguiente modo:

\beforeverb
\begin{verbatim}
inp = raw_input('Introduce la Temperatura Fahrenheit:')
try:
    fahr = float(inp)
    cel = (fahr - 32.0) * 5.0 / 9.0
    print cel
except:
    print 'Por favor, introduce un número'
\end{verbatim}
\afterverb
%

Python comienza ejecutando la
secuencia de setencias del bloque
{\tt try}. Si todo va bien,
saltará el bloque {\tt except} y terminará.
Si ocurre una excepción en el bloque {\tt try},
Python saltará fuera del bloque {\tt try} y
executará la secuencia de sentencias en el bloque {\tt except}.

\beforeverb
\begin{verbatim}
python fahren2.py 
Introduce la Temperatura Fahrenheit:72
22.2222222222

python fahren2.py 
Introduce la Temperatura Fahrenheit:fred
Por favor, introduce un número
\end{verbatim}
\afterverb
%

Manejar una excepción con una sentencia {\tt try} recibe el nombre de
{\bf capturar} una excepción. En este ejemplo, la claúsula {\tt except}
muestra un mensaje de error. En general,
capturar una excepción te da la oportunidad de corregir el problema
o volverlo a intentar, o al menos de terminar el programa con gracia.

\section{Evalucación en corto-circuito de expresiones lógicas}
\index{short circuit}

Cuando Python está procesando una expresión lógica, como
{\tt x >= 2 and (x/y) > 2}, evalúa la expresión de
izquierda a derecha. Debido a la definición de {\tt and},
si {\tt x} es menor de 2, la expresión {\tt x >= 2} resulta ser
{\tt falsa}, de modo que la expresión completa es {\tt falsa}, independientemente
de si {\tt (x/y) > 2} se evalúa como {\tt verdadero} o {\\ falso}.

Cuando Python detecta que no se gana nada evaluando
el resto de una expresión lógica, detiene su evaluación y no
realiza el cálculo del resto de la expresión lógica.
Cuando la evaluación de una expresión lógica se detiene debido a que
ya se conoce el valor final, esto es conocido como {\bf corto-circuitar}
la evaluación.

\index{guardian pattern}
\index{pattern!guardian}
A pesar de que esto pueda parecer hilar demasiado fino, el funcionamiento
en corto-circuito nos dirige a una astuta técnica llamada el {\bf patrón guardián}.
Considera la siguiente secuencia de código en el intérprete de Python:

\beforeverb
\begin{verbatim}
>>> x = 6 
>>> y = 2
>>> x >= 2 and (x/y) > 2
True
>>> x = 1 
>>> y = 0
>>> x >= 2 and (x/y) > 2
False
>>> x = 6
>>> y = 0
>>> x >= 2 and (x/y) > 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
>>> 
\end{verbatim}
\afterverb
%
El tercer cálculo ha fallado porque Python intentó evaluar {\tt (x/y)}
e {\tt y} era cero, lo cual provoca un runtime error (error en tiempo de ejecución). Pero el segundo
ejemplo \emph{no} falló, porque la primera parte de la expresión {\tt x >= 2}
fue evaluada como {\tt falsa}, así que {\tt (x/y)} no llegó a ejecutarse
debido a la regla del {\bf corto-circuito}, y no se produjo ningún error.

Es posible construir las expresiones lógicas colocando estratégicamente una
evaluación {\bf guardián} justo antes de la evaluación que podría causar un error,
como se muestra a continuación:

\beforeverb
\begin{verbatim}
>>> x = 1
>>> y = 0
>>> x >= 2 and y != 0 and (x/y) > 2
False
>>> x = 6 
>>> y = 0
>>> x >= 2 and y != 0 and (x/y) > 2
False
>>> x >= 2 and (x/y) > 2 and y != 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
>>>
\end{verbatim}
\afterverb
%
En la primera expresión lógica, {\tt x >= 2} es {\tt falsa}, así que la evaluación
se detiene en el {\tt and}. En la segunda expresión lógica, {\tt x >= 2} es {\tt verdadera},
pero {\tt y != 0} es {\tt falsa}, de modo que nunca se alcanza {\tt (x/y)}.

En la tercera expresión lógica, el {\tt y != 0} va \emph{después} del
cálculo de {\tt (x/y) }, de modo que la expresión falla con un error.

En la segunda expresión, se dice que {\tt y != 0} actúa como {\bf guardián}
para asegurar que sólo se ejecute {\tt (x/y)} en el caso de que {\tt y} no sea cero.


\section{Depurando}
\label{whitespace}
\index{debugging}
\index{traceback}

Los ``traceback'' que Python muestra cuando se produce un error contienen
un montón de información, pero pueden resultar abrumadores. Las partes
más útiles normalmente son:

\begin{itemize}

\item Qué tipo de error se ha producido, y

\item Dónde ha ocurrido.

\end{itemize}

Los errorres de sintaxis (syntax errors), normalmente son fáciles de encontrar, pero
tienen alguna trampa. Los errores debido a espacios en blanco pueden tener truco,
ya que los espacios y las tabulaciones son invisibles, y solemos ignorarlos.

\index{whitespace}

\beforeverb
\begin{verbatim}
>>> x = 5
>>>  y = 6
  File "<stdin>", line 1
    y = 6
    ^
SyntaxError: invalid syntax
\end{verbatim}
\afterverb
%
En este ejemplo, el problema es que la segunda línea está sangrada por
un espacio. Pero el mensaje de error apunta a {\tt y}, lo cual
resulta engañoso. En general, los mensajes de error indican dónde se ha
descubierto el problema, pero el error real podría estar en el código
previo, a veces en alguna línea anterior.

\index{error!runtime}
\index{runtime error}

Ocurre lo mismo con los errores en tiempo de ejecución (runtime errors). Supón que estás tratando
de calcular una relación señal-ruido en decibelios. La fórmula
es $SNR_{db} = 10 \log_{10} (P_{señal} / P_{ruido})$. En Python,
podrías escribir algo como esto:

\beforeverb
\begin{verbatim}
import math
int_senal = 9
int_ruido = 10
relacion = int_senal / int_ruido
decibelios = 10 * math.log10(relacion)
print decibelios
\end{verbatim}
\afterverb
%
Pero cuando lo haces funcionar, obtienes un mensaje de error\footnote{En Python 3.0,
ya no tendrás un mensaje de error; el operador de división realiza
división en punto flotante incluso con operandos enteros.}:

\index{exception!OverflowError}
\index{OverflowError}

\beforeverb
\begin{verbatim}
Traceback (most recent call last):
  File "snr.py", line 5, in ?
    decibelios = 10 * math.log10(relacion)
OverflowError: math range error
\end{verbatim}
\afterverb
%
El mensaje de error apunta a la línea 5, pero no hay nada
incorrecto en ese línea. Para encontrar el error real, puede resultar
útil imprimir el valor de {\tt relacion}, que resulta ser
0. El problema está en la línea 4, ya que al dividir dos enteros
se realiza una división hacia abajo. La solución es representar la intensidad
de la señal y la intensidad del ruido con valores en punto flotante.

\index{floor division}
\index{division!floor}

En general, los mensajes de error te dicen dónde se ha descubierto el problema,
pero a menudo no es precisamente ahí donde se ha producido.


\section{Glosario}

\begin{description}

\item[cuerpo:] La secuencia de setencias en el interior de una sentencia compuesta.
\index{body}

\item[expresión booleana:]  Un expresión cuyo valor puede ser o bien 
{\tt Verdadero} o bien {\tt Falso}.
\index{boolean expression}
\index{expression!boolean}

\item[rama:] Una de las secuencias alternativas de sentencias en una
sentencia condicional.
\index{branch}

\item[condicional encadenada:]  Una sentencia condicional con una serie
de ramas alternativas.
\index{chained conditional}
\index{conditional!chained}

\item[operadores de comparación:] Uno de los operadores que compara
sus operandos: {\tt ==}, {\tt !=}, {\tt >}, {\tt <}, {\tt >=}, y {\tt <=}.

\item[sentencia condicional:]  Una sentencia que controla el flujo de
ejecución, dependiendo de cierta condición.
\index{conditional statement}
\index{statement!conditional}

\item[condición:] La expresión booleana en una sentencia condicional
que determina qué rama será ejecutada.
\index{condition}

\item[sentencia compuesta:]  Una sentencia que consiste en un encabezado
y un cuerpo. El encabezado termina con dos-puntos (:). El cuerpo está sangrado
con relación al encabezado.
\index{compound statement}

\item[patrón guardián:] Cuando construimos una expresión lógica
con comparaciones adicionales
para aprovecharnos del funcionamiento en corto-circuito.
\index{guardian pattern}
\index{pattern!guardian}

\item[operador lógico:] Uno de los operadores que se combinan en las expresiones
booleanas: {\tt and}, {\tt or}, y {\tt not}.

\item[condicional anidado:]  Una sentencia condicional que aparece
en una de las ramas de otra sentencia condicional.
\index{nested conditional}
\index{conditional!nested}

\item[traceback:]  Una lista de las funciones que se están ejecutando,
que se imprime cuando se produce una excepción.
\index{traceback}

\item[corto circuito:]  Cuando Python va evaluando una expresión lógica
por tramos y detiene el proceso de evaluación debido a que ya
conoce el valor final que va a tener el resultado
sin necesidad de evaluar el resto de la expresión.
\index{short circuit}

\end{description}

\section{Ejercicicos}

\begin{ex}
Reescribe el cálculo del salario para darle al empleado 1.5
veces la tarifa horaria para
las horas trabajadas que excedan de 40.

\begin{verbatim}
Introduce las Horas: 45
Introduce la Tarifa por hora: 10
Salario: 475.0
\end{verbatim}
\end{ex}

\begin{ex}
Reescribe el programa del salario usando {\tt try} y {\tt except},
de modo que el programa sea capaz de manejar entradas no numéricas con elegancia,
mostrando un mensaje y saliendo del programa.
A continuación se muestran dos ejecuciones del programa:

\begin{verbatim}
Introduce las Horas: 20
Introduce la Tarifa por hora: nueve
Error, por favor introduce un número

Introduce las Horas: cuarenta
Error, por favor introduce un número
\end{verbatim}
\end{ex}

\begin{ex}
Escribe un programa que solicite una puntuación entra 0.0 y 1.0.
Si la puntuación está fuera de ese rango, muestra un mensaje de error.
Si la puntuación está entre 0.0 y 1.0, muestra la nota usando la tabla
siguiente:

\begin{verbatim}
Puntuación Nota
>= 0.9     Sobresaliente
>= 0.8     Notable
>= 0.7     Bien
>= 0.6     Suficiente
< 0.6      Insuficiente

Introduce puntuación: 0.95
Sobresaliente

Introduce puntuación: perfecto
Puntuación incorrecta

Introduce puntuación: 10.0
Puntuación incorrecta

Introduce puntuación: 0.75
Bien

Introduce puntuación: 0.5
Insuficiente
\end{verbatim}

Ejecuta el programa repetidamente, como se muestra arriba, para probar
con varios valores de entrada diferentes.
\end{ex}

